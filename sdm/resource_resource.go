// Code generated by protogen. DO NOT EDIT.

package sdm

import (
	"context"
	"errors"
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	sdm "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk"
)

func resourceResource() *schema.Resource {
	return &schema.Resource{
		CreateContext: wrapCrudOperation(resourceResourceCreate),
		ReadContext:   wrapCrudOperation(resourceResourceRead),
		UpdateContext: wrapCrudOperation(resourceResourceUpdate),
		DeleteContext: wrapCrudOperation(resourceResourceDelete),
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"aks": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aks_basic_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aks_service_account": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_token_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_token_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aks_service_account_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_token_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_token_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aks_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks_instance_profile": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks_instance_profile_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_es": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazonmq_amqp_091": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"athena": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"output": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aurora_mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aurora_postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aws": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aws_console": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "AWSConsole is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"enable_env_variables": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"session_expiry": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aws_console_static_key_pair": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "AWSConsoleStaticKeyPair is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"session_expiry": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"azure": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_app_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_app_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tenant_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_tenant_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_tenant_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"azure_certificate": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_app_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_app_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tenant_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_tenant_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_tenant_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"azure_mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"azure_postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"big_query": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"private_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_private_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_private_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"project": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"cassandra": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"citus": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"clustrix": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"cockroach": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"db_2_i": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"db_2_luw": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"document_db_host": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"document_db_replica_set": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"druid": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"dynamo_db": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"elastic": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"elasticache_redis": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"gcp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"keyfile": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_keyfile_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_keyfile_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"scopes": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"google_gke": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"service_account_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_service_account_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_service_account_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"google_gke_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"service_account_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_service_account_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_service_account_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"greenplum": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"http_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_header": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_auth_header_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_auth_header_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"host_override": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
					},
				},
			},
			"http_basic_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"host_override": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"http_no_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"host_override": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
					},
				},
			},
			"kubernetes": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"kubernetes_basic_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"kubernetes_service_account": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_token_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_token_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"kubernetes_service_account_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_token_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_token_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"kubernetes_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"maria": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"memcached": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"memsql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_host": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "MongoHost is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_legacy_host": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_legacy_replicaset": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_replica_set": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "MongoReplicaSet is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_sharded_cluster": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "MongoShardedCluster is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mtls_mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "MTLSMysql is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"server_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mtls_postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"server_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"neptune": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"neptune_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"oracle": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"presto": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"rabbitmq_amqp_091": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"raw_tcp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"rdp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"downgrade_nla_connections": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"redis": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"redshift": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"single_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"snowflake": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"schema": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"snowsight": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Snowsight is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"saml_metadata": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_saml_metadata_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_saml_metadata_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"sql_server": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"schema": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"ssh": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"key_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"public_key": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"ssh_cert": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"key_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"remote_identity_group_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"remote_identity_healthcheck_username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"ssh_customer_key": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"private_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_private_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_private_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"sybase": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"sybase_iq": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"teradata": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"trino": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Trino is currently unstable, and its API may change, or it may be removed, without a major version bump.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bind_interface": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Bind interface",
						},
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
		},
		Timeouts: &schema.ResourceTimeout{
			Default: schema.DefaultTimeout(60 * time.Second),
		},
	}
}
func secretStoreValuesForResource(d *schema.ResourceData) (map[string]string, error) {
	if list := d.Get("aks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"client_certificate":                      convertStringToPlumbing(raw["client_certificate"]),
			"secret_store_client_certificate_path":    convertStringToPlumbing(raw["secret_store_client_certificate_path"]),
			"secret_store_client_certificate_key":     convertStringToPlumbing(raw["secret_store_client_certificate_key"]),
			"client_key":                              convertStringToPlumbing(raw["client_key"]),
			"secret_store_client_key_path":            convertStringToPlumbing(raw["secret_store_client_key_path"]),
			"secret_store_client_key_key":             convertStringToPlumbing(raw["secret_store_client_key_key"]),
		}, nil
	}
	if list := d.Get("aks_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("aks_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential token cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_token_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_token_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"token":                   convertStringToPlumbing(raw["token"]),
			"secret_store_token_path": convertStringToPlumbing(raw["secret_store_token_path"]),
			"secret_store_token_key":  convertStringToPlumbing(raw["secret_store_token_key"]),
		}, nil
	}
	if list := d.Get("aks_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential token cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_token_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_token_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"token":                   convertStringToPlumbing(raw["token"]),
			"secret_store_token_path": convertStringToPlumbing(raw["secret_store_token_path"]),
			"secret_store_token_key":  convertStringToPlumbing(raw["secret_store_token_key"]),
		}, nil
	}
	if list := d.Get("aks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"client_certificate":                      convertStringToPlumbing(raw["client_certificate"]),
			"secret_store_client_certificate_path":    convertStringToPlumbing(raw["secret_store_client_certificate_path"]),
			"secret_store_client_certificate_key":     convertStringToPlumbing(raw["secret_store_client_certificate_key"]),
			"client_key":                              convertStringToPlumbing(raw["client_key"]),
			"secret_store_client_key_path":            convertStringToPlumbing(raw["secret_store_client_key_path"]),
			"secret_store_client_key_key":             convertStringToPlumbing(raw["secret_store_client_key_key"]),
		}, nil
	}
	if list := d.Get("amazon_eks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                              convertStringToPlumbing(raw["access_key"]),
			"secret_store_access_key_path":            convertStringToPlumbing(raw["secret_store_access_key_path"]),
			"secret_store_access_key_key":             convertStringToPlumbing(raw["secret_store_access_key_key"]),
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"role_arn":                                convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":              convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":               convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                        convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":      convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":       convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
			"secret_access_key":                       convertStringToPlumbing(raw["secret_access_key"]),
			"secret_store_secret_access_key_path":     convertStringToPlumbing(raw["secret_store_secret_access_key_path"]),
			"secret_store_secret_access_key_key":      convertStringToPlumbing(raw["secret_store_secret_access_key_key"]),
		}, nil
	}
	if list := d.Get("amazon_eks_instance_profile").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"role_arn":                                convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":              convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":               convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                        convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":      convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":       convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
		}, nil
	}
	if list := d.Get("amazon_eks_instance_profile_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"role_arn":                                convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":              convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":               convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                        convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":      convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":       convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
		}, nil
	}
	if list := d.Get("amazon_eks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                              convertStringToPlumbing(raw["access_key"]),
			"secret_store_access_key_path":            convertStringToPlumbing(raw["secret_store_access_key_path"]),
			"secret_store_access_key_key":             convertStringToPlumbing(raw["secret_store_access_key_key"]),
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"role_arn":                                convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":              convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":               convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                        convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":      convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":       convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
			"secret_access_key":                       convertStringToPlumbing(raw["secret_access_key"]),
			"secret_store_secret_access_key_path":     convertStringToPlumbing(raw["secret_store_secret_access_key_path"]),
			"secret_store_secret_access_key_key":      convertStringToPlumbing(raw["secret_store_secret_access_key_key"]),
		}, nil
	}
	if list := d.Get("amazon_es").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringToPlumbing(raw["access_key"]),
			"secret_store_access_key_path":        convertStringToPlumbing(raw["secret_store_access_key_path"]),
			"secret_store_access_key_key":         convertStringToPlumbing(raw["secret_store_access_key_key"]),
			"role_arn":                            convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":          convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":           convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                    convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":  convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":   convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
			"secret_access_key":                   convertStringToPlumbing(raw["secret_access_key"]),
			"secret_store_secret_access_key_path": convertStringToPlumbing(raw["secret_store_secret_access_key_path"]),
			"secret_store_secret_access_key_key":  convertStringToPlumbing(raw["secret_store_secret_access_key_key"]),
		}, nil
	}
	if list := d.Get("amazonmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("athena").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringToPlumbing(raw["access_key"]),
			"secret_store_access_key_path":        convertStringToPlumbing(raw["secret_store_access_key_path"]),
			"secret_store_access_key_key":         convertStringToPlumbing(raw["secret_store_access_key_key"]),
			"role_arn":                            convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":          convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":           convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                    convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":  convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":   convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
			"secret_access_key":                   convertStringToPlumbing(raw["secret_access_key"]),
			"secret_store_secret_access_key_path": convertStringToPlumbing(raw["secret_store_secret_access_key_path"]),
			"secret_store_secret_access_key_key":  convertStringToPlumbing(raw["secret_store_secret_access_key_key"]),
		}, nil
	}
	if list := d.Get("aurora_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("aurora_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("aws").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringToPlumbing(raw["access_key"]),
			"secret_store_access_key_path":        convertStringToPlumbing(raw["secret_store_access_key_path"]),
			"secret_store_access_key_key":         convertStringToPlumbing(raw["secret_store_access_key_key"]),
			"role_arn":                            convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":          convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":           convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                    convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":  convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":   convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
			"secret_access_key":                   convertStringToPlumbing(raw["secret_access_key"]),
			"secret_store_secret_access_key_path": convertStringToPlumbing(raw["secret_store_secret_access_key_path"]),
			"secret_store_secret_access_key_key":  convertStringToPlumbing(raw["secret_store_secret_access_key_key"]),
		}, nil
	}
	if list := d.Get("aws_console").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"role_arn":                           convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":         convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":          convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                   convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path": convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":  convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
		}, nil
	}
	if list := d.Get("aws_console_static_key_pair").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringToPlumbing(raw["access_key"]),
			"secret_store_access_key_path":        convertStringToPlumbing(raw["secret_store_access_key_path"]),
			"secret_store_access_key_key":         convertStringToPlumbing(raw["secret_store_access_key_key"]),
			"role_arn":                            convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":          convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":           convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                    convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":  convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":   convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
			"secret_access_key":                   convertStringToPlumbing(raw["secret_access_key"]),
			"secret_store_secret_access_key_path": convertStringToPlumbing(raw["secret_store_secret_access_key_path"]),
			"secret_store_secret_access_key_key":  convertStringToPlumbing(raw["secret_store_secret_access_key_key"]),
		}, nil
	}
	if list := d.Get("azure").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["app_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential app_id cannot be combined with secret_store_id")
			}
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["tenant_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential tenant_id cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_app_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_app_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_app_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_app_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_tenant_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_tenant_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_tenant_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_tenant_id_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"app_id":                      convertStringToPlumbing(raw["app_id"]),
			"secret_store_app_id_path":    convertStringToPlumbing(raw["secret_store_app_id_path"]),
			"secret_store_app_id_key":     convertStringToPlumbing(raw["secret_store_app_id_key"]),
			"password":                    convertStringToPlumbing(raw["password"]),
			"secret_store_password_path":  convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":   convertStringToPlumbing(raw["secret_store_password_key"]),
			"tenant_id":                   convertStringToPlumbing(raw["tenant_id"]),
			"secret_store_tenant_id_path": convertStringToPlumbing(raw["secret_store_tenant_id_path"]),
			"secret_store_tenant_id_key":  convertStringToPlumbing(raw["secret_store_tenant_id_key"]),
		}, nil
	}
	if list := d.Get("azure_certificate").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["app_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential app_id cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["tenant_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential tenant_id cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_app_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_app_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_app_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_app_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_tenant_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_tenant_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_tenant_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_tenant_id_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"app_id":                               convertStringToPlumbing(raw["app_id"]),
			"secret_store_app_id_path":             convertStringToPlumbing(raw["secret_store_app_id_path"]),
			"secret_store_app_id_key":              convertStringToPlumbing(raw["secret_store_app_id_key"]),
			"client_certificate":                   convertStringToPlumbing(raw["client_certificate"]),
			"secret_store_client_certificate_path": convertStringToPlumbing(raw["secret_store_client_certificate_path"]),
			"secret_store_client_certificate_key":  convertStringToPlumbing(raw["secret_store_client_certificate_key"]),
			"tenant_id":                            convertStringToPlumbing(raw["tenant_id"]),
			"secret_store_tenant_id_path":          convertStringToPlumbing(raw["secret_store_tenant_id_path"]),
			"secret_store_tenant_id_key":           convertStringToPlumbing(raw["secret_store_tenant_id_key"]),
		}, nil
	}
	if list := d.Get("azure_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("azure_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("big_query").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["private_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential private_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_private_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_private_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_private_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_private_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"private_key":                   convertStringToPlumbing(raw["private_key"]),
			"secret_store_private_key_path": convertStringToPlumbing(raw["secret_store_private_key_path"]),
			"secret_store_private_key_key":  convertStringToPlumbing(raw["secret_store_private_key_key"]),
		}, nil
	}
	if list := d.Get("cassandra").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("citus").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("clustrix").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("cockroach").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("db_2_i").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("db_2_luw").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("document_db_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("document_db_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("druid").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("dynamo_db").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringToPlumbing(raw["access_key"]),
			"secret_store_access_key_path":        convertStringToPlumbing(raw["secret_store_access_key_path"]),
			"secret_store_access_key_key":         convertStringToPlumbing(raw["secret_store_access_key_key"]),
			"role_arn":                            convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":          convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":           convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                    convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":  convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":   convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
			"secret_access_key":                   convertStringToPlumbing(raw["secret_access_key"]),
			"secret_store_secret_access_key_path": convertStringToPlumbing(raw["secret_store_secret_access_key_path"]),
			"secret_store_secret_access_key_key":  convertStringToPlumbing(raw["secret_store_secret_access_key_key"]),
		}, nil
	}
	if list := d.Get("elastic").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("elasticache_redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("gcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["keyfile"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential keyfile cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_keyfile_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_keyfile_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_keyfile_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_keyfile_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"keyfile":                   convertStringToPlumbing(raw["keyfile"]),
			"secret_store_keyfile_path": convertStringToPlumbing(raw["secret_store_keyfile_path"]),
			"secret_store_keyfile_key":  convertStringToPlumbing(raw["secret_store_keyfile_key"]),
		}, nil
	}
	if list := d.Get("google_gke").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["service_account_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential service_account_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_service_account_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_service_account_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_service_account_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_service_account_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"service_account_key":                     convertStringToPlumbing(raw["service_account_key"]),
			"secret_store_service_account_key_path":   convertStringToPlumbing(raw["secret_store_service_account_key_path"]),
			"secret_store_service_account_key_key":    convertStringToPlumbing(raw["secret_store_service_account_key_key"]),
		}, nil
	}
	if list := d.Get("google_gke_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["service_account_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential service_account_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_service_account_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_service_account_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_service_account_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_service_account_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"service_account_key":                     convertStringToPlumbing(raw["service_account_key"]),
			"secret_store_service_account_key_path":   convertStringToPlumbing(raw["secret_store_service_account_key_path"]),
			"secret_store_service_account_key_key":    convertStringToPlumbing(raw["secret_store_service_account_key_key"]),
		}, nil
	}
	if list := d.Get("greenplum").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("http_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["auth_header"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential auth_header cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_auth_header_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_auth_header_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_auth_header_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_auth_header_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"auth_header":                   convertStringToPlumbing(raw["auth_header"]),
			"secret_store_auth_header_path": convertStringToPlumbing(raw["secret_store_auth_header_path"]),
			"secret_store_auth_header_key":  convertStringToPlumbing(raw["secret_store_auth_header_key"]),
		}, nil
	}
	if list := d.Get("http_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("http_no_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		} else {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("kubernetes").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"client_certificate":                      convertStringToPlumbing(raw["client_certificate"]),
			"secret_store_client_certificate_path":    convertStringToPlumbing(raw["secret_store_client_certificate_path"]),
			"secret_store_client_certificate_key":     convertStringToPlumbing(raw["secret_store_client_certificate_key"]),
			"client_key":                              convertStringToPlumbing(raw["client_key"]),
			"secret_store_client_key_path":            convertStringToPlumbing(raw["secret_store_client_key_path"]),
			"secret_store_client_key_key":             convertStringToPlumbing(raw["secret_store_client_key_key"]),
		}, nil
	}
	if list := d.Get("kubernetes_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("kubernetes_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential token cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_token_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_token_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"token":                   convertStringToPlumbing(raw["token"]),
			"secret_store_token_path": convertStringToPlumbing(raw["secret_store_token_path"]),
			"secret_store_token_key":  convertStringToPlumbing(raw["secret_store_token_key"]),
		}, nil
	}
	if list := d.Get("kubernetes_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential token cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_token_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_token_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"token":                   convertStringToPlumbing(raw["token"]),
			"secret_store_token_path": convertStringToPlumbing(raw["secret_store_token_path"]),
			"secret_store_token_key":  convertStringToPlumbing(raw["secret_store_token_key"]),
		}, nil
	}
	if list := d.Get("kubernetes_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"client_certificate":                      convertStringToPlumbing(raw["client_certificate"]),
			"secret_store_client_certificate_path":    convertStringToPlumbing(raw["secret_store_client_certificate_path"]),
			"secret_store_client_certificate_key":     convertStringToPlumbing(raw["secret_store_client_certificate_key"]),
			"client_key":                              convertStringToPlumbing(raw["client_key"]),
			"secret_store_client_key_path":            convertStringToPlumbing(raw["secret_store_client_key_path"]),
			"secret_store_client_key_key":             convertStringToPlumbing(raw["secret_store_client_key_key"]),
		}, nil
	}
	if list := d.Get("maria").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("memcached").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		} else {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("memsql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("mongo_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("mongo_legacy_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("mongo_legacy_replicaset").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("mongo_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("mongo_sharded_cluster").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("mtls_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"client_certificate":                      convertStringToPlumbing(raw["client_certificate"]),
			"secret_store_client_certificate_path":    convertStringToPlumbing(raw["secret_store_client_certificate_path"]),
			"secret_store_client_certificate_key":     convertStringToPlumbing(raw["secret_store_client_certificate_key"]),
			"client_key":                              convertStringToPlumbing(raw["client_key"]),
			"secret_store_client_key_path":            convertStringToPlumbing(raw["secret_store_client_key_path"]),
			"secret_store_client_key_key":             convertStringToPlumbing(raw["secret_store_client_key_key"]),
			"password":                                convertStringToPlumbing(raw["password"]),
			"secret_store_password_path":              convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":               convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                                convertStringToPlumbing(raw["username"]),
			"secret_store_username_path":              convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":               convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("mtls_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringToPlumbing(raw["certificate_authority"]),
			"secret_store_certificate_authority_path": convertStringToPlumbing(raw["secret_store_certificate_authority_path"]),
			"secret_store_certificate_authority_key":  convertStringToPlumbing(raw["secret_store_certificate_authority_key"]),
			"client_certificate":                      convertStringToPlumbing(raw["client_certificate"]),
			"secret_store_client_certificate_path":    convertStringToPlumbing(raw["secret_store_client_certificate_path"]),
			"secret_store_client_certificate_key":     convertStringToPlumbing(raw["secret_store_client_certificate_key"]),
			"client_key":                              convertStringToPlumbing(raw["client_key"]),
			"secret_store_client_key_path":            convertStringToPlumbing(raw["secret_store_client_key_path"]),
			"secret_store_client_key_key":             convertStringToPlumbing(raw["secret_store_client_key_key"]),
			"password":                                convertStringToPlumbing(raw["password"]),
			"secret_store_password_path":              convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":               convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                                convertStringToPlumbing(raw["username"]),
			"secret_store_username_path":              convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":               convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("neptune").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		} else {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("neptune_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringToPlumbing(raw["access_key"]),
			"secret_store_access_key_path":        convertStringToPlumbing(raw["secret_store_access_key_path"]),
			"secret_store_access_key_key":         convertStringToPlumbing(raw["secret_store_access_key_key"]),
			"role_arn":                            convertStringToPlumbing(raw["role_arn"]),
			"secret_store_role_arn_path":          convertStringToPlumbing(raw["secret_store_role_arn_path"]),
			"secret_store_role_arn_key":           convertStringToPlumbing(raw["secret_store_role_arn_key"]),
			"role_external_id":                    convertStringToPlumbing(raw["role_external_id"]),
			"secret_store_role_external_id_path":  convertStringToPlumbing(raw["secret_store_role_external_id_path"]),
			"secret_store_role_external_id_key":   convertStringToPlumbing(raw["secret_store_role_external_id_key"]),
			"secret_access_key":                   convertStringToPlumbing(raw["secret_access_key"]),
			"secret_store_secret_access_key_path": convertStringToPlumbing(raw["secret_store_secret_access_key_path"]),
			"secret_store_secret_access_key_key":  convertStringToPlumbing(raw["secret_store_secret_access_key_key"]),
		}, nil
	}
	if list := d.Get("oracle").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("presto").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
		}, nil
	}
	if list := d.Get("rabbitmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("raw_tcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		} else {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("rdp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("redshift").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("single_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("snowflake").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("snowsight").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["saml_metadata"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential saml_metadata cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_saml_metadata_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_saml_metadata_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_saml_metadata_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_saml_metadata_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"saml_metadata":                   convertStringToPlumbing(raw["saml_metadata"]),
			"secret_store_saml_metadata_path": convertStringToPlumbing(raw["secret_store_saml_metadata_path"]),
			"secret_store_saml_metadata_key":  convertStringToPlumbing(raw["secret_store_saml_metadata_key"]),
		}, nil
	}
	if list := d.Get("sql_server").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("ssh_cert").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("ssh_customer_key").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["private_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential private_key cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_private_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_private_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_private_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_private_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"private_key":                   convertStringToPlumbing(raw["private_key"]),
			"secret_store_private_key_path": convertStringToPlumbing(raw["secret_store_private_key_path"]),
			"secret_store_private_key_key":  convertStringToPlumbing(raw["secret_store_private_key_key"]),
			"username":                      convertStringToPlumbing(raw["username"]),
			"secret_store_username_path":    convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":     convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("sybase").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("sybase_iq").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("teradata").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
			"username":                   convertStringToPlumbing(raw["username"]),
			"secret_store_username_path": convertStringToPlumbing(raw["secret_store_username_path"]),
			"secret_store_username_key":  convertStringToPlumbing(raw["secret_store_username_key"]),
		}, nil
	}
	if list := d.Get("trino").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringToPlumbing(raw["password"]),
			"secret_store_password_path": convertStringToPlumbing(raw["secret_store_password_path"]),
			"secret_store_password_key":  convertStringToPlumbing(raw["secret_store_password_key"]),
		}, nil
	}
	return map[string]string{}, nil
}
func convertResourceToPlumbing(d *schema.ResourceData) sdm.Resource {
	if list := d.Get("aks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKS{}
		}
		out := &sdm.AKS{
			ID:                                d.Id(),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:              convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:                 convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:                         convertStringToPlumbing(raw["client_key"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace:              convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:                          convertStringToPlumbing(raw["hostname"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			Port:                              convertInt32ToPlumbing(raw["port"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		return out
	}
	if list := d.Get("aks_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSBasicAuth{}
		}
		out := &sdm.AKSBasicAuth{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Password:             convertStringToPlumbing(raw["password"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Username:             convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("aks_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSServiceAccount{}
		}
		out := &sdm.AKSServiceAccount{
			ID:                                d.Id(),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace:              convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:                          convertStringToPlumbing(raw["hostname"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			Port:                              convertInt32ToPlumbing(raw["port"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
			Token:                             convertStringToPlumbing(raw["token"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Token == "" {
			out.Token = fullSecretStorePath(raw, "token")
		}
		return out
	}
	if list := d.Get("aks_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSServiceAccountUserImpersonation{}
		}
		out := &sdm.AKSServiceAccountUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Token:                convertStringToPlumbing(raw["token"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Token == "" {
			out.Token = fullSecretStorePath(raw, "token")
		}
		return out
	}
	if list := d.Get("aks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSUserImpersonation{}
		}
		out := &sdm.AKSUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:    convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:            convertStringToPlumbing(raw["client_key"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		return out
	}
	if list := d.Get("amazon_eks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKS{}
		}
		out := &sdm.AmazonEKS{
			ID:                                d.Id(),
			AccessKey:                         convertStringToPlumbing(raw["access_key"]),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:              convertStringToPlumbing(raw["certificate_authority"]),
			ClusterName:                       convertStringToPlumbing(raw["cluster_name"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:                          convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace:              convertStringToPlumbing(raw["healthcheck_namespace"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			Region:                            convertStringToPlumbing(raw["region"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			RoleArn:                           convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:                    convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey:                   convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("amazon_eks_instance_profile").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKSInstanceProfile{}
		}
		out := &sdm.AmazonEKSInstanceProfile{
			ID:                                d.Id(),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:              convertStringToPlumbing(raw["certificate_authority"]),
			ClusterName:                       convertStringToPlumbing(raw["cluster_name"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:                          convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace:              convertStringToPlumbing(raw["healthcheck_namespace"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			Region:                            convertStringToPlumbing(raw["region"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			RoleArn:                           convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:                    convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		return out
	}
	if list := d.Get("amazon_eks_instance_profile_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKSInstanceProfileUserImpersonation{}
		}
		out := &sdm.AmazonEKSInstanceProfileUserImpersonation{
			ID:                                d.Id(),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:              convertStringToPlumbing(raw["certificate_authority"]),
			ClusterName:                       convertStringToPlumbing(raw["cluster_name"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:                          convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace:              convertStringToPlumbing(raw["healthcheck_namespace"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			Region:                            convertStringToPlumbing(raw["region"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			RoleArn:                           convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:                    convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		return out
	}
	if list := d.Get("amazon_eks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKSUserImpersonation{}
		}
		out := &sdm.AmazonEKSUserImpersonation{
			ID:                   d.Id(),
			AccessKey:            convertStringToPlumbing(raw["access_key"]),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClusterName:          convertStringToPlumbing(raw["cluster_name"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:             convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			Region:               convertStringToPlumbing(raw["region"]),
			RoleArn:              convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:       convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey:      convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("amazon_es").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonES{}
		}
		out := &sdm.AmazonES{
			ID:              d.Id(),
			AccessKey:       convertStringToPlumbing(raw["access_key"]),
			BindInterface:   convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:    convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:        convertStringToPlumbing(raw["endpoint"]),
			Name:            convertStringToPlumbing(raw["name"]),
			PortOverride:    convertInt32ToPlumbing(raw["port_override"]),
			Region:          convertStringToPlumbing(raw["region"]),
			RoleArn:         convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:  convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey: convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:   convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:       convertStringToPlumbing(raw["subdomain"]),
			Tags:            convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("amazonmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonMQAMQP091{}
		}
		out := &sdm.AmazonMQAMQP091{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("athena").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Athena{}
		}
		out := &sdm.Athena{
			ID:              d.Id(),
			AccessKey:       convertStringToPlumbing(raw["access_key"]),
			BindInterface:   convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:    convertStringToPlumbing(raw["egress_filter"]),
			Name:            convertStringToPlumbing(raw["name"]),
			Output:          convertStringToPlumbing(raw["output"]),
			PortOverride:    convertInt32ToPlumbing(raw["port_override"]),
			Region:          convertStringToPlumbing(raw["region"]),
			RoleArn:         convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:  convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey: convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:   convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:       convertStringToPlumbing(raw["subdomain"]),
			Tags:            convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("aurora_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraMysql{}
		}
		out := &sdm.AuroraMysql{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("aurora_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraPostgres{}
		}
		out := &sdm.AuroraPostgres{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("aws").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWS{}
		}
		out := &sdm.AWS{
			ID:                d.Id(),
			AccessKey:         convertStringToPlumbing(raw["access_key"]),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckRegion: convertStringToPlumbing(raw["healthcheck_region"]),
			Name:              convertStringToPlumbing(raw["name"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			RoleArn:           convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:    convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey:   convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("aws_console").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWSConsole{}
		}
		out := &sdm.AWSConsole{
			ID:                                d.Id(),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			EnableEnvVariables:                convertBoolToPlumbing(raw["enable_env_variables"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			Region:                            convertStringToPlumbing(raw["region"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			RoleArn:                           convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:                    convertStringToPlumbing(raw["role_external_id"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			SessionExpiry:                     convertInt32ToPlumbing(raw["session_expiry"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		return out
	}
	if list := d.Get("aws_console_static_key_pair").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWSConsoleStaticKeyPair{}
		}
		out := &sdm.AWSConsoleStaticKeyPair{
			ID:                                d.Id(),
			AccessKey:                         convertStringToPlumbing(raw["access_key"]),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			Region:                            convertStringToPlumbing(raw["region"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			RoleArn:                           convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:                    convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey:                   convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			SessionExpiry:                     convertInt32ToPlumbing(raw["session_expiry"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("azure").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Azure{}
		}
		out := &sdm.Azure{
			ID:            d.Id(),
			AppID:         convertStringToPlumbing(raw["app_id"]),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TenantID:      convertStringToPlumbing(raw["tenant_id"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AppID == "" {
			out.AppID = fullSecretStorePath(raw, "app_id")
		}
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.TenantID == "" {
			out.TenantID = fullSecretStorePath(raw, "tenant_id")
		}
		return out
	}
	if list := d.Get("azure_certificate").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzureCertificate{}
		}
		out := &sdm.AzureCertificate{
			ID:                d.Id(),
			AppID:             convertStringToPlumbing(raw["app_id"]),
			BindInterface:     convertStringToPlumbing(raw["bind_interface"]),
			ClientCertificate: convertStringToPlumbing(raw["client_certificate"]),
			EgressFilter:      convertStringToPlumbing(raw["egress_filter"]),
			Name:              convertStringToPlumbing(raw["name"]),
			PortOverride:      convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:         convertStringToPlumbing(raw["subdomain"]),
			Tags:              convertTagsToPlumbing(raw["tags"]),
			TenantID:          convertStringToPlumbing(raw["tenant_id"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AppID == "" {
			out.AppID = fullSecretStorePath(raw, "app_id")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.TenantID == "" {
			out.TenantID = fullSecretStorePath(raw, "tenant_id")
		}
		return out
	}
	if list := d.Get("azure_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzureMysql{}
		}
		out := &sdm.AzureMysql{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("azure_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzurePostgres{}
		}
		out := &sdm.AzurePostgres{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("big_query").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.BigQuery{}
		}
		out := &sdm.BigQuery{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:      convertStringToPlumbing(raw["endpoint"]),
			Name:          convertStringToPlumbing(raw["name"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			PrivateKey:    convertStringToPlumbing(raw["private_key"]),
			Project:       convertStringToPlumbing(raw["project"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.PrivateKey == "" {
			out.PrivateKey = fullSecretStorePath(raw, "private_key")
		}
		return out
	}
	if list := d.Get("cassandra").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Cassandra{}
		}
		out := &sdm.Cassandra{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("citus").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Citus{}
		}
		out := &sdm.Citus{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("clustrix").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Clustrix{}
		}
		out := &sdm.Clustrix{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("cockroach").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Cockroach{}
		}
		out := &sdm.Cockroach{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("db_2_i").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DB2I{}
		}
		out := &sdm.DB2I{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("db_2_luw").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DB2LUW{}
		}
		out := &sdm.DB2LUW{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("document_db_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DocumentDBHost{}
		}
		out := &sdm.DocumentDBHost{
			ID:            d.Id(),
			AuthDatabase:  convertStringToPlumbing(raw["auth_database"]),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("document_db_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DocumentDBReplicaSet{}
		}
		out := &sdm.DocumentDBReplicaSet{
			ID:               d.Id(),
			AuthDatabase:     convertStringToPlumbing(raw["auth_database"]),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			ConnectToReplica: convertBoolToPlumbing(raw["connect_to_replica"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			Password:         convertStringToPlumbing(raw["password"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ReplicaSet:       convertStringToPlumbing(raw["replica_set"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("druid").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Druid{}
		}
		out := &sdm.Druid{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("dynamo_db").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DynamoDB{}
		}
		out := &sdm.DynamoDB{
			ID:              d.Id(),
			AccessKey:       convertStringToPlumbing(raw["access_key"]),
			BindInterface:   convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:    convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:        convertStringToPlumbing(raw["endpoint"]),
			Name:            convertStringToPlumbing(raw["name"]),
			PortOverride:    convertInt32ToPlumbing(raw["port_override"]),
			Region:          convertStringToPlumbing(raw["region"]),
			RoleArn:         convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:  convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey: convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:   convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:       convertStringToPlumbing(raw["subdomain"]),
			Tags:            convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("elastic").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Elastic{}
		}
		out := &sdm.Elastic{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("elasticache_redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.ElasticacheRedis{}
		}
		out := &sdm.ElasticacheRedis{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("gcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GCP{}
		}
		out := &sdm.GCP{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Keyfile:       convertStringToPlumbing(raw["keyfile"]),
			Name:          convertStringToPlumbing(raw["name"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			Scopes:        convertStringToPlumbing(raw["scopes"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Keyfile == "" {
			out.Keyfile = fullSecretStorePath(raw, "keyfile")
		}
		return out
	}
	if list := d.Get("google_gke").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GoogleGKE{}
		}
		out := &sdm.GoogleGKE{
			ID:                                d.Id(),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:              convertStringToPlumbing(raw["certificate_authority"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:                          convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace:              convertStringToPlumbing(raw["healthcheck_namespace"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			ServiceAccountKey:                 convertStringToPlumbing(raw["service_account_key"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ServiceAccountKey == "" {
			out.ServiceAccountKey = fullSecretStorePath(raw, "service_account_key")
		}
		return out
	}
	if list := d.Get("google_gke_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GoogleGKEUserImpersonation{}
		}
		out := &sdm.GoogleGKEUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:             convertStringToPlumbing(raw["endpoint"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			ServiceAccountKey:    convertStringToPlumbing(raw["service_account_key"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ServiceAccountKey == "" {
			out.ServiceAccountKey = fullSecretStorePath(raw, "service_account_key")
		}
		return out
	}
	if list := d.Get("greenplum").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Greenplum{}
		}
		out := &sdm.Greenplum{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("http_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPAuth{}
		}
		out := &sdm.HTTPAuth{
			ID:               d.Id(),
			AuthHeader:       convertStringToPlumbing(raw["auth_header"]),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			DefaultPath:      convertStringToPlumbing(raw["default_path"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			HeadersBlacklist: convertStringToPlumbing(raw["headers_blacklist"]),
			HealthcheckPath:  convertStringToPlumbing(raw["healthcheck_path"]),
			HostOverride:     convertStringToPlumbing(raw["host_override"]),
			Name:             convertStringToPlumbing(raw["name"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Url:              convertStringToPlumbing(raw["url"]),
		}
		if out.AuthHeader == "" {
			out.AuthHeader = fullSecretStorePath(raw, "auth_header")
		}
		return out
	}
	if list := d.Get("http_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPBasicAuth{}
		}
		out := &sdm.HTTPBasicAuth{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			DefaultPath:      convertStringToPlumbing(raw["default_path"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			HeadersBlacklist: convertStringToPlumbing(raw["headers_blacklist"]),
			HealthcheckPath:  convertStringToPlumbing(raw["healthcheck_path"]),
			HostOverride:     convertStringToPlumbing(raw["host_override"]),
			Name:             convertStringToPlumbing(raw["name"]),
			Password:         convertStringToPlumbing(raw["password"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Url:              convertStringToPlumbing(raw["url"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("http_no_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPNoAuth{}
		}
		out := &sdm.HTTPNoAuth{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			DefaultPath:      convertStringToPlumbing(raw["default_path"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			HeadersBlacklist: convertStringToPlumbing(raw["headers_blacklist"]),
			HealthcheckPath:  convertStringToPlumbing(raw["healthcheck_path"]),
			HostOverride:     convertStringToPlumbing(raw["host_override"]),
			Name:             convertStringToPlumbing(raw["name"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Url:              convertStringToPlumbing(raw["url"]),
		}
		return out
	}
	if list := d.Get("kubernetes").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Kubernetes{}
		}
		out := &sdm.Kubernetes{
			ID:                                d.Id(),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority:              convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:                 convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:                         convertStringToPlumbing(raw["client_key"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace:              convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:                          convertStringToPlumbing(raw["hostname"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			Port:                              convertInt32ToPlumbing(raw["port"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		return out
	}
	if list := d.Get("kubernetes_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesBasicAuth{}
		}
		out := &sdm.KubernetesBasicAuth{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Password:             convertStringToPlumbing(raw["password"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Username:             convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("kubernetes_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesServiceAccount{}
		}
		out := &sdm.KubernetesServiceAccount{
			ID:                                d.Id(),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace:              convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:                          convertStringToPlumbing(raw["hostname"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			Port:                              convertInt32ToPlumbing(raw["port"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
			Token:                             convertStringToPlumbing(raw["token"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Token == "" {
			out.Token = fullSecretStorePath(raw, "token")
		}
		return out
	}
	if list := d.Get("kubernetes_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesServiceAccountUserImpersonation{}
		}
		out := &sdm.KubernetesServiceAccountUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Token:                convertStringToPlumbing(raw["token"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Token == "" {
			out.Token = fullSecretStorePath(raw, "token")
		}
		return out
	}
	if list := d.Get("kubernetes_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesUserImpersonation{}
		}
		out := &sdm.KubernetesUserImpersonation{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:    convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:            convertStringToPlumbing(raw["client_key"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckNamespace: convertStringToPlumbing(raw["healthcheck_namespace"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		return out
	}
	if list := d.Get("maria").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Maria{}
		}
		out := &sdm.Maria{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("memcached").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Memcached{}
		}
		out := &sdm.Memcached{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("memsql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Memsql{}
		}
		out := &sdm.Memsql{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoHost{}
		}
		out := &sdm.MongoHost{
			ID:            d.Id(),
			AuthDatabase:  convertStringToPlumbing(raw["auth_database"]),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_legacy_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoLegacyHost{}
		}
		out := &sdm.MongoLegacyHost{
			ID:            d.Id(),
			AuthDatabase:  convertStringToPlumbing(raw["auth_database"]),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			ReplicaSet:    convertStringToPlumbing(raw["replica_set"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_legacy_replicaset").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoLegacyReplicaset{}
		}
		out := &sdm.MongoLegacyReplicaset{
			ID:               d.Id(),
			AuthDatabase:     convertStringToPlumbing(raw["auth_database"]),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			ConnectToReplica: convertBoolToPlumbing(raw["connect_to_replica"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ReplicaSet:       convertStringToPlumbing(raw["replica_set"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			TlsRequired:      convertBoolToPlumbing(raw["tls_required"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoReplicaSet{}
		}
		out := &sdm.MongoReplicaSet{
			ID:               d.Id(),
			AuthDatabase:     convertStringToPlumbing(raw["auth_database"]),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			ConnectToReplica: convertBoolToPlumbing(raw["connect_to_replica"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			ReplicaSet:       convertStringToPlumbing(raw["replica_set"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			TlsRequired:      convertBoolToPlumbing(raw["tls_required"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_sharded_cluster").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoShardedCluster{}
		}
		out := &sdm.MongoShardedCluster{
			ID:            d.Id(),
			AuthDatabase:  convertStringToPlumbing(raw["auth_database"]),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mtls_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MTLSMysql{}
		}
		out := &sdm.MTLSMysql{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:    convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:            convertStringToPlumbing(raw["client_key"]),
			Database:             convertStringToPlumbing(raw["database"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			Password:             convertStringToPlumbing(raw["password"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			ServerName:           convertStringToPlumbing(raw["server_name"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Username:             convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mtls_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MTLSPostgres{}
		}
		out := &sdm.MTLSPostgres{
			ID:                   d.Id(),
			BindInterface:        convertStringToPlumbing(raw["bind_interface"]),
			CertificateAuthority: convertStringToPlumbing(raw["certificate_authority"]),
			ClientCertificate:    convertStringToPlumbing(raw["client_certificate"]),
			ClientKey:            convertStringToPlumbing(raw["client_key"]),
			Database:             convertStringToPlumbing(raw["database"]),
			EgressFilter:         convertStringToPlumbing(raw["egress_filter"]),
			Hostname:             convertStringToPlumbing(raw["hostname"]),
			Name:                 convertStringToPlumbing(raw["name"]),
			OverrideDatabase:     convertBoolToPlumbing(raw["override_database"]),
			Password:             convertStringToPlumbing(raw["password"]),
			Port:                 convertInt32ToPlumbing(raw["port"]),
			PortOverride:         convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:        convertStringToPlumbing(raw["secret_store_id"]),
			ServerName:           convertStringToPlumbing(raw["server_name"]),
			Subdomain:            convertStringToPlumbing(raw["subdomain"]),
			Tags:                 convertTagsToPlumbing(raw["tags"]),
			Username:             convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Mysql{}
		}
		out := &sdm.Mysql{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("neptune").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Neptune{}
		}
		out := &sdm.Neptune{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:      convertStringToPlumbing(raw["endpoint"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("neptune_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.NeptuneIAM{}
		}
		out := &sdm.NeptuneIAM{
			ID:              d.Id(),
			AccessKey:       convertStringToPlumbing(raw["access_key"]),
			BindInterface:   convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:    convertStringToPlumbing(raw["egress_filter"]),
			Endpoint:        convertStringToPlumbing(raw["endpoint"]),
			Name:            convertStringToPlumbing(raw["name"]),
			Port:            convertInt32ToPlumbing(raw["port"]),
			PortOverride:    convertInt32ToPlumbing(raw["port_override"]),
			Region:          convertStringToPlumbing(raw["region"]),
			RoleArn:         convertStringToPlumbing(raw["role_arn"]),
			RoleExternalID:  convertStringToPlumbing(raw["role_external_id"]),
			SecretAccessKey: convertStringToPlumbing(raw["secret_access_key"]),
			SecretStoreID:   convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:       convertStringToPlumbing(raw["subdomain"]),
			Tags:            convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("oracle").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Oracle{}
		}
		out := &sdm.Oracle{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Postgres{}
		}
		out := &sdm.Postgres{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("presto").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Presto{}
		}
		out := &sdm.Presto{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		return out
	}
	if list := d.Get("rabbitmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RabbitMQAMQP091{}
		}
		out := &sdm.RabbitMQAMQP091{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("raw_tcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RawTCP{}
		}
		out := &sdm.RawTCP{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("rdp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RDP{}
		}
		out := &sdm.RDP{
			ID:                      d.Id(),
			BindInterface:           convertStringToPlumbing(raw["bind_interface"]),
			DowngradeNlaConnections: convertBoolToPlumbing(raw["downgrade_nla_connections"]),
			EgressFilter:            convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                convertStringToPlumbing(raw["hostname"]),
			Name:                    convertStringToPlumbing(raw["name"]),
			Password:                convertStringToPlumbing(raw["password"]),
			Port:                    convertInt32ToPlumbing(raw["port"]),
			PortOverride:            convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:           convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:               convertStringToPlumbing(raw["subdomain"]),
			Tags:                    convertTagsToPlumbing(raw["tags"]),
			Username:                convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Redis{}
		}
		out := &sdm.Redis{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			TlsRequired:   convertBoolToPlumbing(raw["tls_required"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("redshift").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Redshift{}
		}
		out := &sdm.Redshift{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("single_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SingleStore{}
		}
		out := &sdm.SingleStore{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("snowflake").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Snowflake{}
		}
		out := &sdm.Snowflake{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			Schema:        convertStringToPlumbing(raw["schema"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("snowsight").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Snowsight{}
		}
		out := &sdm.Snowsight{
			ID:                  d.Id(),
			BindInterface:       convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:        convertStringToPlumbing(raw["egress_filter"]),
			HealthcheckUsername: convertStringToPlumbing(raw["healthcheck_username"]),
			Name:                convertStringToPlumbing(raw["name"]),
			PortOverride:        convertInt32ToPlumbing(raw["port_override"]),
			SamlMetadata:        convertStringToPlumbing(raw["saml_metadata"]),
			SecretStoreID:       convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:           convertStringToPlumbing(raw["subdomain"]),
			Tags:                convertTagsToPlumbing(raw["tags"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.SamlMetadata == "" {
			out.SamlMetadata = fullSecretStorePath(raw, "saml_metadata")
		}
		return out
	}
	if list := d.Get("sql_server").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SQLServer{}
		}
		out := &sdm.SQLServer{
			ID:               d.Id(),
			BindInterface:    convertStringToPlumbing(raw["bind_interface"]),
			Database:         convertStringToPlumbing(raw["database"]),
			EgressFilter:     convertStringToPlumbing(raw["egress_filter"]),
			Hostname:         convertStringToPlumbing(raw["hostname"]),
			Name:             convertStringToPlumbing(raw["name"]),
			OverrideDatabase: convertBoolToPlumbing(raw["override_database"]),
			Password:         convertStringToPlumbing(raw["password"]),
			Port:             convertInt32ToPlumbing(raw["port"]),
			PortOverride:     convertInt32ToPlumbing(raw["port_override"]),
			Schema:           convertStringToPlumbing(raw["schema"]),
			SecretStoreID:    convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:        convertStringToPlumbing(raw["subdomain"]),
			Tags:             convertTagsToPlumbing(raw["tags"]),
			Username:         convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSH{}
		}
		out := &sdm.SSH{
			ID:                          d.Id(),
			AllowDeprecatedKeyExchanges: convertBoolToPlumbing(raw["allow_deprecated_key_exchanges"]),
			BindInterface:               convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                    convertStringToPlumbing(raw["hostname"]),
			KeyType:                     convertStringToPlumbing(raw["key_type"]),
			Name:                        convertStringToPlumbing(raw["name"]),
			Port:                        convertInt32ToPlumbing(raw["port"]),
			PortForwarding:              convertBoolToPlumbing(raw["port_forwarding"]),
			PortOverride:                convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID:               convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                   convertStringToPlumbing(raw["subdomain"]),
			Tags:                        convertTagsToPlumbing(raw["tags"]),
			Username:                    convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("ssh_cert").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSHCert{}
		}
		out := &sdm.SSHCert{
			ID:                                d.Id(),
			AllowDeprecatedKeyExchanges:       convertBoolToPlumbing(raw["allow_deprecated_key_exchanges"]),
			BindInterface:                     convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                      convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                          convertStringToPlumbing(raw["hostname"]),
			KeyType:                           convertStringToPlumbing(raw["key_type"]),
			Name:                              convertStringToPlumbing(raw["name"]),
			Port:                              convertInt32ToPlumbing(raw["port"]),
			PortForwarding:                    convertBoolToPlumbing(raw["port_forwarding"]),
			PortOverride:                      convertInt32ToPlumbing(raw["port_override"]),
			RemoteIdentityGroupID:             convertStringToPlumbing(raw["remote_identity_group_id"]),
			RemoteIdentityHealthcheckUsername: convertStringToPlumbing(raw["remote_identity_healthcheck_username"]),
			SecretStoreID:                     convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                         convertStringToPlumbing(raw["subdomain"]),
			Tags:                              convertTagsToPlumbing(raw["tags"]),
			Username:                          convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("ssh_customer_key").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSHCustomerKey{}
		}
		out := &sdm.SSHCustomerKey{
			ID:                          d.Id(),
			AllowDeprecatedKeyExchanges: convertBoolToPlumbing(raw["allow_deprecated_key_exchanges"]),
			BindInterface:               convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:                convertStringToPlumbing(raw["egress_filter"]),
			Hostname:                    convertStringToPlumbing(raw["hostname"]),
			Name:                        convertStringToPlumbing(raw["name"]),
			Port:                        convertInt32ToPlumbing(raw["port"]),
			PortForwarding:              convertBoolToPlumbing(raw["port_forwarding"]),
			PortOverride:                convertInt32ToPlumbing(raw["port_override"]),
			PrivateKey:                  convertStringToPlumbing(raw["private_key"]),
			SecretStoreID:               convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:                   convertStringToPlumbing(raw["subdomain"]),
			Tags:                        convertTagsToPlumbing(raw["tags"]),
			Username:                    convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.PrivateKey == "" {
			out.PrivateKey = fullSecretStorePath(raw, "private_key")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("sybase").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Sybase{}
		}
		out := &sdm.Sybase{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("sybase_iq").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SybaseIQ{}
		}
		out := &sdm.SybaseIQ{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("teradata").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Teradata{}
		}
		out := &sdm.Teradata{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("trino").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Trino{}
		}
		out := &sdm.Trino{
			ID:            d.Id(),
			BindInterface: convertStringToPlumbing(raw["bind_interface"]),
			Database:      convertStringToPlumbing(raw["database"]),
			EgressFilter:  convertStringToPlumbing(raw["egress_filter"]),
			Hostname:      convertStringToPlumbing(raw["hostname"]),
			Name:          convertStringToPlumbing(raw["name"]),
			Password:      convertStringToPlumbing(raw["password"]),
			Port:          convertInt32ToPlumbing(raw["port"]),
			PortOverride:  convertInt32ToPlumbing(raw["port_override"]),
			SecretStoreID: convertStringToPlumbing(raw["secret_store_id"]),
			Subdomain:     convertStringToPlumbing(raw["subdomain"]),
			Tags:          convertTagsToPlumbing(raw["tags"]),
			Username:      convertStringToPlumbing(raw["username"]),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		return out
	}
	return nil
}

func resourceResourceCreate(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	localVersion := convertResourceToPlumbing(d)
	seValues, err := secretStoreValuesForResource(d)
	if err != nil {
		return fmt.Errorf("cannot create Resource: %w", err)
	}
	resp, err := cc.Resources().Create(ctx, localVersion)
	if err != nil {
		return fmt.Errorf("cannot create Resource: %w", err)
	}
	d.SetId(resp.Resource.GetID())
	switch v := resp.Resource.(type) {
	case *sdm.AKS:
		localV, _ := localVersion.(*sdm.AKS)
		_ = localV
		d.Set("aks", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AKSBasicAuth:
		localV, _ := localVersion.(*sdm.AKSBasicAuth)
		_ = localV
		d.Set("aks_basic_auth", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"healthcheck_namespace":      (v.HealthcheckNamespace),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AKSServiceAccount:
		localV, _ := localVersion.(*sdm.AKSServiceAccount)
		_ = localV
		d.Set("aks_service_account", []map[string]interface{}{
			{
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"hostname":                             (v.Hostname),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"token":                                seValues["token"],
				"secret_store_token_path":              seValues["secret_store_token_path"],
				"secret_store_token_key":               seValues["secret_store_token_key"],
			},
		})
	case *sdm.AKSServiceAccountUserImpersonation:
		localV, _ := localVersion.(*sdm.AKSServiceAccountUserImpersonation)
		_ = localV
		d.Set("aks_service_account_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":          (v.BindInterface),
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"port_override":           (v.PortOverride),
				"secret_store_id":         (v.SecretStoreID),
				"subdomain":               (v.Subdomain),
				"tags":                    convertTagsToPorcelain(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.AKSUserImpersonation:
		localV, _ := localVersion.(*sdm.AKSUserImpersonation)
		_ = localV
		d.Set("aks_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKS:
		localV, _ := localVersion.(*sdm.AmazonEKS)
		_ = localV
		d.Set("amazon_eks", []map[string]interface{}{
			{
				"access_key":                              seValues["access_key"],
				"secret_store_access_key_path":            seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":             seValues["secret_store_access_key_key"],
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"port_override":                           (v.PortOverride),
				"region":                                  (v.Region),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_access_key":                       seValues["secret_access_key"],
				"secret_store_secret_access_key_path":     seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":      seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSInstanceProfile:
		localV, _ := localVersion.(*sdm.AmazonEKSInstanceProfile)
		_ = localV
		d.Set("amazon_eks_instance_profile", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"port_override":                           (v.PortOverride),
				"region":                                  (v.Region),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSInstanceProfileUserImpersonation:
		localV, _ := localVersion.(*sdm.AmazonEKSInstanceProfileUserImpersonation)
		_ = localV
		d.Set("amazon_eks_instance_profile_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"port_override":                           (v.PortOverride),
				"region":                                  (v.Region),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSUserImpersonation:
		localV, _ := localVersion.(*sdm.AmazonEKSUserImpersonation)
		_ = localV
		d.Set("amazon_eks_user_impersonation", []map[string]interface{}{
			{
				"access_key":                              seValues["access_key"],
				"secret_store_access_key_path":            seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":             seValues["secret_store_access_key_key"],
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"port_override":                           (v.PortOverride),
				"region":                                  (v.Region),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_access_key":                       seValues["secret_access_key"],
				"secret_store_secret_access_key_path":     seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":      seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonES:
		localV, _ := localVersion.(*sdm.AmazonES)
		_ = localV
		d.Set("amazon_es", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonMQAMQP091:
		localV, _ := localVersion.(*sdm.AmazonMQAMQP091)
		_ = localV
		d.Set("amazonmq_amqp_091", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Athena:
		localV, _ := localVersion.(*sdm.Athena)
		_ = localV
		d.Set("athena", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"name":                                (v.Name),
				"output":                              (v.Output),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AuroraMysql:
		localV, _ := localVersion.(*sdm.AuroraMysql)
		_ = localV
		d.Set("aurora_mysql", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AuroraPostgres:
		localV, _ := localVersion.(*sdm.AuroraPostgres)
		_ = localV
		d.Set("aurora_postgres", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AWS:
		localV, _ := localVersion.(*sdm.AWS)
		_ = localV
		d.Set("aws", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_region":                  (v.HealthcheckRegion),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSConsole:
		localV, _ := localVersion.(*sdm.AWSConsole)
		_ = localV
		d.Set("aws_console", []map[string]interface{}{
			{
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"enable_env_variables":                 (v.EnableEnvVariables),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"region":                               (v.Region),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                             seValues["role_arn"],
				"secret_store_role_arn_path":           seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":            seValues["secret_store_role_arn_key"],
				"role_external_id":                     seValues["role_external_id"],
				"secret_store_role_external_id_path":   seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":    seValues["secret_store_role_external_id_key"],
				"secret_store_id":                      (v.SecretStoreID),
				"session_expiry":                       (v.SessionExpiry),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSConsoleStaticKeyPair:
		localV, _ := localVersion.(*sdm.AWSConsoleStaticKeyPair)
		_ = localV
		d.Set("aws_console_static_key_pair", []map[string]interface{}{
			{
				"access_key":                           seValues["access_key"],
				"secret_store_access_key_path":         seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":          seValues["secret_store_access_key_key"],
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"region":                               (v.Region),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                             seValues["role_arn"],
				"secret_store_role_arn_path":           seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":            seValues["secret_store_role_arn_key"],
				"role_external_id":                     seValues["role_external_id"],
				"secret_store_role_external_id_path":   seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":    seValues["secret_store_role_external_id_key"],
				"secret_access_key":                    seValues["secret_access_key"],
				"secret_store_secret_access_key_path":  seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":   seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                      (v.SecretStoreID),
				"session_expiry":                       (v.SessionExpiry),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Azure:
		localV, _ := localVersion.(*sdm.Azure)
		_ = localV
		d.Set("azure", []map[string]interface{}{
			{
				"app_id":                      seValues["app_id"],
				"secret_store_app_id_path":    seValues["secret_store_app_id_path"],
				"secret_store_app_id_key":     seValues["secret_store_app_id_key"],
				"bind_interface":              (v.BindInterface),
				"egress_filter":               (v.EgressFilter),
				"name":                        (v.Name),
				"password":                    seValues["password"],
				"secret_store_password_path":  seValues["secret_store_password_path"],
				"secret_store_password_key":   seValues["secret_store_password_key"],
				"port_override":               (v.PortOverride),
				"secret_store_id":             (v.SecretStoreID),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"tenant_id":                   seValues["tenant_id"],
				"secret_store_tenant_id_path": seValues["secret_store_tenant_id_path"],
				"secret_store_tenant_id_key":  seValues["secret_store_tenant_id_key"],
			},
		})
	case *sdm.AzureCertificate:
		localV, _ := localVersion.(*sdm.AzureCertificate)
		_ = localV
		d.Set("azure_certificate", []map[string]interface{}{
			{
				"app_id":                               seValues["app_id"],
				"secret_store_app_id_path":             seValues["secret_store_app_id_path"],
				"secret_store_app_id_key":              seValues["secret_store_app_id_key"],
				"bind_interface":                       (v.BindInterface),
				"client_certificate":                   seValues["client_certificate"],
				"secret_store_client_certificate_path": seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":  seValues["secret_store_client_certificate_key"],
				"egress_filter":                        (v.EgressFilter),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"tenant_id":                            seValues["tenant_id"],
				"secret_store_tenant_id_path":          seValues["secret_store_tenant_id_path"],
				"secret_store_tenant_id_key":           seValues["secret_store_tenant_id_key"],
			},
		})
	case *sdm.AzureMysql:
		localV, _ := localVersion.(*sdm.AzureMysql)
		_ = localV
		d.Set("azure_mysql", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AzurePostgres:
		localV, _ := localVersion.(*sdm.AzurePostgres)
		_ = localV
		d.Set("azure_postgres", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.BigQuery:
		localV, _ := localVersion.(*sdm.BigQuery)
		_ = localV
		d.Set("big_query", []map[string]interface{}{
			{
				"bind_interface":                (v.BindInterface),
				"egress_filter":                 (v.EgressFilter),
				"endpoint":                      (v.Endpoint),
				"name":                          (v.Name),
				"port_override":                 (v.PortOverride),
				"private_key":                   seValues["private_key"],
				"secret_store_private_key_path": seValues["secret_store_private_key_path"],
				"secret_store_private_key_key":  seValues["secret_store_private_key_key"],
				"project":                       (v.Project),
				"secret_store_id":               (v.SecretStoreID),
				"subdomain":                     (v.Subdomain),
				"tags":                          convertTagsToPorcelain(v.Tags),
				"username":                      (v.Username),
			},
		})
	case *sdm.Cassandra:
		localV, _ := localVersion.(*sdm.Cassandra)
		_ = localV
		d.Set("cassandra", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Citus:
		localV, _ := localVersion.(*sdm.Citus)
		_ = localV
		d.Set("citus", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Clustrix:
		localV, _ := localVersion.(*sdm.Clustrix)
		_ = localV
		d.Set("clustrix", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Cockroach:
		localV, _ := localVersion.(*sdm.Cockroach)
		_ = localV
		d.Set("cockroach", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DB2I:
		localV, _ := localVersion.(*sdm.DB2I)
		_ = localV
		d.Set("db_2_i", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DB2LUW:
		localV, _ := localVersion.(*sdm.DB2LUW)
		_ = localV
		d.Set("db_2_luw", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DocumentDBHost:
		localV, _ := localVersion.(*sdm.DocumentDBHost)
		_ = localV
		d.Set("document_db_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DocumentDBReplicaSet:
		localV, _ := localVersion.(*sdm.DocumentDBReplicaSet)
		_ = localV
		d.Set("document_db_replica_set", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Druid:
		localV, _ := localVersion.(*sdm.Druid)
		_ = localV
		d.Set("druid", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DynamoDB:
		localV, _ := localVersion.(*sdm.DynamoDB)
		_ = localV
		d.Set("dynamo_db", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Elastic:
		localV, _ := localVersion.(*sdm.Elastic)
		_ = localV
		d.Set("elastic", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.ElasticacheRedis:
		localV, _ := localVersion.(*sdm.ElasticacheRedis)
		_ = localV
		d.Set("elasticache_redis", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.GCP:
		localV, _ := localVersion.(*sdm.GCP)
		_ = localV
		d.Set("gcp", []map[string]interface{}{
			{
				"bind_interface":            (v.BindInterface),
				"egress_filter":             (v.EgressFilter),
				"keyfile":                   seValues["keyfile"],
				"secret_store_keyfile_path": seValues["secret_store_keyfile_path"],
				"secret_store_keyfile_key":  seValues["secret_store_keyfile_key"],
				"name":                      (v.Name),
				"port_override":             (v.PortOverride),
				"scopes":                    (v.Scopes),
				"secret_store_id":           (v.SecretStoreID),
				"subdomain":                 (v.Subdomain),
				"tags":                      convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GoogleGKE:
		localV, _ := localVersion.(*sdm.GoogleGKE)
		_ = localV
		d.Set("google_gke", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                         (v.SecretStoreID),
				"service_account_key":                     seValues["service_account_key"],
				"secret_store_service_account_key_path":   seValues["secret_store_service_account_key_path"],
				"secret_store_service_account_key_key":    seValues["secret_store_service_account_key_key"],
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GoogleGKEUserImpersonation:
		localV, _ := localVersion.(*sdm.GoogleGKEUserImpersonation)
		_ = localV
		d.Set("google_gke_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"secret_store_id":                         (v.SecretStoreID),
				"service_account_key":                     seValues["service_account_key"],
				"secret_store_service_account_key_path":   seValues["secret_store_service_account_key_path"],
				"secret_store_service_account_key_key":    seValues["secret_store_service_account_key_key"],
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Greenplum:
		localV, _ := localVersion.(*sdm.Greenplum)
		_ = localV
		d.Set("greenplum", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.HTTPAuth:
		localV, _ := localVersion.(*sdm.HTTPAuth)
		_ = localV
		d.Set("http_auth", []map[string]interface{}{
			{
				"auth_header":                   seValues["auth_header"],
				"secret_store_auth_header_path": seValues["secret_store_auth_header_path"],
				"secret_store_auth_header_key":  seValues["secret_store_auth_header_key"],
				"bind_interface":                (v.BindInterface),
				"default_path":                  (v.DefaultPath),
				"egress_filter":                 (v.EgressFilter),
				"headers_blacklist":             (v.HeadersBlacklist),
				"healthcheck_path":              (v.HealthcheckPath),
				"host_override":                 (v.HostOverride),
				"name":                          (v.Name),
				"secret_store_id":               (v.SecretStoreID),
				"subdomain":                     (v.Subdomain),
				"tags":                          convertTagsToPorcelain(v.Tags),
				"url":                           (v.Url),
			},
		})
	case *sdm.HTTPBasicAuth:
		localV, _ := localVersion.(*sdm.HTTPBasicAuth)
		_ = localV
		d.Set("http_basic_auth", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"default_path":               (v.DefaultPath),
				"egress_filter":              (v.EgressFilter),
				"headers_blacklist":          (v.HeadersBlacklist),
				"healthcheck_path":           (v.HealthcheckPath),
				"host_override":              (v.HostOverride),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"url":                        (v.Url),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.HTTPNoAuth:
		localV, _ := localVersion.(*sdm.HTTPNoAuth)
		_ = localV
		d.Set("http_no_auth", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"name":              (v.Name),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
			},
		})
	case *sdm.Kubernetes:
		localV, _ := localVersion.(*sdm.Kubernetes)
		_ = localV
		d.Set("kubernetes", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KubernetesBasicAuth:
		localV, _ := localVersion.(*sdm.KubernetesBasicAuth)
		_ = localV
		d.Set("kubernetes_basic_auth", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"healthcheck_namespace":      (v.HealthcheckNamespace),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.KubernetesServiceAccount:
		localV, _ := localVersion.(*sdm.KubernetesServiceAccount)
		_ = localV
		d.Set("kubernetes_service_account", []map[string]interface{}{
			{
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"hostname":                             (v.Hostname),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"token":                                seValues["token"],
				"secret_store_token_path":              seValues["secret_store_token_path"],
				"secret_store_token_key":               seValues["secret_store_token_key"],
			},
		})
	case *sdm.KubernetesServiceAccountUserImpersonation:
		localV, _ := localVersion.(*sdm.KubernetesServiceAccountUserImpersonation)
		_ = localV
		d.Set("kubernetes_service_account_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":          (v.BindInterface),
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"port_override":           (v.PortOverride),
				"secret_store_id":         (v.SecretStoreID),
				"subdomain":               (v.Subdomain),
				"tags":                    convertTagsToPorcelain(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.KubernetesUserImpersonation:
		localV, _ := localVersion.(*sdm.KubernetesUserImpersonation)
		_ = localV
		d.Set("kubernetes_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Maria:
		localV, _ := localVersion.(*sdm.Maria)
		_ = localV
		d.Set("maria", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Memcached:
		localV, _ := localVersion.(*sdm.Memcached)
		_ = localV
		d.Set("memcached", []map[string]interface{}{
			{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Memsql:
		localV, _ := localVersion.(*sdm.Memsql)
		_ = localV
		d.Set("memsql", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoHost:
		localV, _ := localVersion.(*sdm.MongoHost)
		_ = localV
		d.Set("mongo_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoLegacyHost:
		localV, _ := localVersion.(*sdm.MongoLegacyHost)
		_ = localV
		d.Set("mongo_legacy_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoLegacyReplicaset:
		localV, _ := localVersion.(*sdm.MongoLegacyReplicaset)
		_ = localV
		d.Set("mongo_legacy_replicaset", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoReplicaSet:
		localV, _ := localVersion.(*sdm.MongoReplicaSet)
		_ = localV
		d.Set("mongo_replica_set", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoShardedCluster:
		localV, _ := localVersion.(*sdm.MongoShardedCluster)
		_ = localV
		d.Set("mongo_sharded_cluster", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MTLSMysql:
		localV, _ := localVersion.(*sdm.MTLSMysql)
		_ = localV
		d.Set("mtls_mysql", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"database":                                (v.Database),
				"egress_filter":                           (v.EgressFilter),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"password":                                seValues["password"],
				"secret_store_password_path":              seValues["secret_store_password_path"],
				"secret_store_password_key":               seValues["secret_store_password_key"],
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"secret_store_id":                         (v.SecretStoreID),
				"server_name":                             (v.ServerName),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
				"username":                                seValues["username"],
				"secret_store_username_path":              seValues["secret_store_username_path"],
				"secret_store_username_key":               seValues["secret_store_username_key"],
			},
		})
	case *sdm.MTLSPostgres:
		localV, _ := localVersion.(*sdm.MTLSPostgres)
		_ = localV
		d.Set("mtls_postgres", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"database":                                (v.Database),
				"egress_filter":                           (v.EgressFilter),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"override_database":                       (v.OverrideDatabase),
				"password":                                seValues["password"],
				"secret_store_password_path":              seValues["secret_store_password_path"],
				"secret_store_password_key":               seValues["secret_store_password_key"],
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"secret_store_id":                         (v.SecretStoreID),
				"server_name":                             (v.ServerName),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
				"username":                                seValues["username"],
				"secret_store_username_path":              seValues["secret_store_username_path"],
				"secret_store_username_key":               seValues["secret_store_username_key"],
			},
		})
	case *sdm.Mysql:
		localV, _ := localVersion.(*sdm.Mysql)
		_ = localV
		d.Set("mysql", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Neptune:
		localV, _ := localVersion.(*sdm.Neptune)
		_ = localV
		d.Set("neptune", []map[string]interface{}{
			{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"endpoint":        (v.Endpoint),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.NeptuneIAM:
		localV, _ := localVersion.(*sdm.NeptuneIAM)
		_ = localV
		d.Set("neptune_iam", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Oracle:
		localV, _ := localVersion.(*sdm.Oracle)
		_ = localV
		d.Set("oracle", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Postgres:
		localV, _ := localVersion.(*sdm.Postgres)
		_ = localV
		d.Set("postgres", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Presto:
		localV, _ := localVersion.(*sdm.Presto)
		_ = localV
		d.Set("presto", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   (v.Username),
			},
		})
	case *sdm.RabbitMQAMQP091:
		localV, _ := localVersion.(*sdm.RabbitMQAMQP091)
		_ = localV
		d.Set("rabbitmq_amqp_091", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.RawTCP:
		localV, _ := localVersion.(*sdm.RawTCP)
		_ = localV
		d.Set("raw_tcp", []map[string]interface{}{
			{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.RDP:
		localV, _ := localVersion.(*sdm.RDP)
		_ = localV
		d.Set("rdp", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"downgrade_nla_connections":  (v.DowngradeNlaConnections),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Redis:
		localV, _ := localVersion.(*sdm.Redis)
		_ = localV
		d.Set("redis", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Redshift:
		localV, _ := localVersion.(*sdm.Redshift)
		_ = localV
		d.Set("redshift", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SingleStore:
		localV, _ := localVersion.(*sdm.SingleStore)
		_ = localV
		d.Set("single_store", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Snowflake:
		localV, _ := localVersion.(*sdm.Snowflake)
		_ = localV
		d.Set("snowflake", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"schema":                     (v.Schema),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Snowsight:
		localV, _ := localVersion.(*sdm.Snowsight)
		_ = localV
		d.Set("snowsight", []map[string]interface{}{
			{
				"bind_interface":                  (v.BindInterface),
				"egress_filter":                   (v.EgressFilter),
				"healthcheck_username":            (v.HealthcheckUsername),
				"name":                            (v.Name),
				"port_override":                   (v.PortOverride),
				"saml_metadata":                   seValues["saml_metadata"],
				"secret_store_saml_metadata_path": seValues["secret_store_saml_metadata_path"],
				"secret_store_saml_metadata_key":  seValues["secret_store_saml_metadata_key"],
				"secret_store_id":                 (v.SecretStoreID),
				"subdomain":                       (v.Subdomain),
				"tags":                            convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.SQLServer:
		localV, _ := localVersion.(*sdm.SQLServer)
		_ = localV
		d.Set("sql_server", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"schema":                     (v.Schema),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSH:
		localV, _ := localVersion.(*sdm.SSH)
		_ = localV
		d.Set("ssh", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"key_type":                       (v.KeyType),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"public_key":                     (v.PublicKey),
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSHCert:
		localV, _ := localVersion.(*sdm.SSHCert)
		_ = localV
		d.Set("ssh_cert", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges":       (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"hostname":                             (v.Hostname),
				"key_type":                             (v.KeyType),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_forwarding":                      (v.PortForwarding),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"username":                             seValues["username"],
				"secret_store_username_path":           seValues["secret_store_username_path"],
				"secret_store_username_key":            seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSHCustomerKey:
		localV, _ := localVersion.(*sdm.SSHCustomerKey)
		_ = localV
		d.Set("ssh_customer_key", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"private_key":                    seValues["private_key"],
				"secret_store_private_key_path":  seValues["secret_store_private_key_path"],
				"secret_store_private_key_key":   seValues["secret_store_private_key_key"],
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.Sybase:
		localV, _ := localVersion.(*sdm.Sybase)
		_ = localV
		d.Set("sybase", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SybaseIQ:
		localV, _ := localVersion.(*sdm.SybaseIQ)
		_ = localV
		d.Set("sybase_iq", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Teradata:
		localV, _ := localVersion.(*sdm.Teradata)
		_ = localV
		d.Set("teradata", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Trino:
		localV, _ := localVersion.(*sdm.Trino)
		_ = localV
		d.Set("trino", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   (v.Username),
			},
		})
	}
	return nil
}

func resourceResourceRead(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	localVersion := convertResourceToPlumbing(d)
	_ = localVersion
	seValues, err := secretStoreValuesForResource(d)
	if err != nil {
		return fmt.Errorf("cannot read Resource %s: %w", d.Id(), err)
	}
	resp, err := cc.Resources().Get(ctx, d.Id())
	var errNotFound *sdm.NotFoundError
	if err != nil && errors.As(err, &errNotFound) {
		d.SetId("")
		return nil
	} else if err != nil {
		return fmt.Errorf("cannot read Resource %s: %w", d.Id(), err)
	}
	switch v := resp.Resource.(type) {
	case *sdm.AKS:
		localV, ok := localVersion.(*sdm.AKS)
		if !ok {
			localV = &sdm.AKS{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.ClientCertificate != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientCertificate)
				if err == nil {
					seValues["secret_store_client_certificate_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_certificate_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_certificate"] = v.ClientCertificate
			}
		}
		if v.ClientKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientKey)
				if err == nil {
					seValues["secret_store_client_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_key"] = v.ClientKey
			}
		}
		d.Set("aks", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AKSBasicAuth:
		localV, ok := localVersion.(*sdm.AKSBasicAuth)
		if !ok {
			localV = &sdm.AKSBasicAuth{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("aks_basic_auth", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"healthcheck_namespace":      (v.HealthcheckNamespace),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AKSServiceAccount:
		localV, ok := localVersion.(*sdm.AKSServiceAccount)
		if !ok {
			localV = &sdm.AKSServiceAccount{}
		}
		_ = localV
		if v.Token != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Token)
				if err == nil {
					seValues["secret_store_token_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_token_key"] = u.Query().Get("key")
				}
			} else {
				seValues["token"] = v.Token
			}
		}
		d.Set("aks_service_account", []map[string]interface{}{
			{
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"hostname":                             (v.Hostname),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"token":                                seValues["token"],
				"secret_store_token_path":              seValues["secret_store_token_path"],
				"secret_store_token_key":               seValues["secret_store_token_key"],
			},
		})
	case *sdm.AKSServiceAccountUserImpersonation:
		localV, ok := localVersion.(*sdm.AKSServiceAccountUserImpersonation)
		if !ok {
			localV = &sdm.AKSServiceAccountUserImpersonation{}
		}
		_ = localV
		if v.Token != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Token)
				if err == nil {
					seValues["secret_store_token_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_token_key"] = u.Query().Get("key")
				}
			} else {
				seValues["token"] = v.Token
			}
		}
		d.Set("aks_service_account_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":          (v.BindInterface),
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"port_override":           (v.PortOverride),
				"secret_store_id":         (v.SecretStoreID),
				"subdomain":               (v.Subdomain),
				"tags":                    convertTagsToPorcelain(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.AKSUserImpersonation:
		localV, ok := localVersion.(*sdm.AKSUserImpersonation)
		if !ok {
			localV = &sdm.AKSUserImpersonation{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.ClientCertificate != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientCertificate)
				if err == nil {
					seValues["secret_store_client_certificate_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_certificate_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_certificate"] = v.ClientCertificate
			}
		}
		if v.ClientKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientKey)
				if err == nil {
					seValues["secret_store_client_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_key"] = v.ClientKey
			}
		}
		d.Set("aks_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKS:
		localV, ok := localVersion.(*sdm.AmazonEKS)
		if !ok {
			localV = &sdm.AmazonEKS{}
		}
		_ = localV
		if v.AccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AccessKey)
				if err == nil {
					seValues["secret_store_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["access_key"] = v.AccessKey
			}
		}
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		if v.SecretAccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.SecretAccessKey)
				if err == nil {
					seValues["secret_store_secret_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_secret_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["secret_access_key"] = v.SecretAccessKey
			}
		}
		d.Set("amazon_eks", []map[string]interface{}{
			{
				"access_key":                              seValues["access_key"],
				"secret_store_access_key_path":            seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":             seValues["secret_store_access_key_key"],
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"port_override":                           (v.PortOverride),
				"region":                                  (v.Region),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_access_key":                       seValues["secret_access_key"],
				"secret_store_secret_access_key_path":     seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":      seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSInstanceProfile:
		localV, ok := localVersion.(*sdm.AmazonEKSInstanceProfile)
		if !ok {
			localV = &sdm.AmazonEKSInstanceProfile{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		d.Set("amazon_eks_instance_profile", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"port_override":                           (v.PortOverride),
				"region":                                  (v.Region),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSInstanceProfileUserImpersonation:
		localV, ok := localVersion.(*sdm.AmazonEKSInstanceProfileUserImpersonation)
		if !ok {
			localV = &sdm.AmazonEKSInstanceProfileUserImpersonation{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		d.Set("amazon_eks_instance_profile_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"port_override":                           (v.PortOverride),
				"region":                                  (v.Region),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonEKSUserImpersonation:
		localV, ok := localVersion.(*sdm.AmazonEKSUserImpersonation)
		if !ok {
			localV = &sdm.AmazonEKSUserImpersonation{}
		}
		_ = localV
		if v.AccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AccessKey)
				if err == nil {
					seValues["secret_store_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["access_key"] = v.AccessKey
			}
		}
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		if v.SecretAccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.SecretAccessKey)
				if err == nil {
					seValues["secret_store_secret_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_secret_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["secret_access_key"] = v.SecretAccessKey
			}
		}
		d.Set("amazon_eks_user_impersonation", []map[string]interface{}{
			{
				"access_key":                              seValues["access_key"],
				"secret_store_access_key_path":            seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":             seValues["secret_store_access_key_key"],
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"port_override":                           (v.PortOverride),
				"region":                                  (v.Region),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_access_key":                       seValues["secret_access_key"],
				"secret_store_secret_access_key_path":     seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":      seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonES:
		localV, ok := localVersion.(*sdm.AmazonES)
		if !ok {
			localV = &sdm.AmazonES{}
		}
		_ = localV
		if v.AccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AccessKey)
				if err == nil {
					seValues["secret_store_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["access_key"] = v.AccessKey
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		if v.SecretAccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.SecretAccessKey)
				if err == nil {
					seValues["secret_store_secret_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_secret_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["secret_access_key"] = v.SecretAccessKey
			}
		}
		d.Set("amazon_es", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AmazonMQAMQP091:
		localV, ok := localVersion.(*sdm.AmazonMQAMQP091)
		if !ok {
			localV = &sdm.AmazonMQAMQP091{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("amazonmq_amqp_091", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Athena:
		localV, ok := localVersion.(*sdm.Athena)
		if !ok {
			localV = &sdm.Athena{}
		}
		_ = localV
		if v.AccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AccessKey)
				if err == nil {
					seValues["secret_store_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["access_key"] = v.AccessKey
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		if v.SecretAccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.SecretAccessKey)
				if err == nil {
					seValues["secret_store_secret_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_secret_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["secret_access_key"] = v.SecretAccessKey
			}
		}
		d.Set("athena", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"name":                                (v.Name),
				"output":                              (v.Output),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AuroraMysql:
		localV, ok := localVersion.(*sdm.AuroraMysql)
		if !ok {
			localV = &sdm.AuroraMysql{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("aurora_mysql", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AuroraPostgres:
		localV, ok := localVersion.(*sdm.AuroraPostgres)
		if !ok {
			localV = &sdm.AuroraPostgres{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("aurora_postgres", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AWS:
		localV, ok := localVersion.(*sdm.AWS)
		if !ok {
			localV = &sdm.AWS{}
		}
		_ = localV
		if v.AccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AccessKey)
				if err == nil {
					seValues["secret_store_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["access_key"] = v.AccessKey
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		if v.SecretAccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.SecretAccessKey)
				if err == nil {
					seValues["secret_store_secret_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_secret_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["secret_access_key"] = v.SecretAccessKey
			}
		}
		d.Set("aws", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_region":                  (v.HealthcheckRegion),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSConsole:
		localV, ok := localVersion.(*sdm.AWSConsole)
		if !ok {
			localV = &sdm.AWSConsole{}
		}
		_ = localV
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		d.Set("aws_console", []map[string]interface{}{
			{
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"enable_env_variables":                 (v.EnableEnvVariables),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"region":                               (v.Region),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                             seValues["role_arn"],
				"secret_store_role_arn_path":           seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":            seValues["secret_store_role_arn_key"],
				"role_external_id":                     seValues["role_external_id"],
				"secret_store_role_external_id_path":   seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":    seValues["secret_store_role_external_id_key"],
				"secret_store_id":                      (v.SecretStoreID),
				"session_expiry":                       (v.SessionExpiry),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.AWSConsoleStaticKeyPair:
		localV, ok := localVersion.(*sdm.AWSConsoleStaticKeyPair)
		if !ok {
			localV = &sdm.AWSConsoleStaticKeyPair{}
		}
		_ = localV
		if v.AccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AccessKey)
				if err == nil {
					seValues["secret_store_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["access_key"] = v.AccessKey
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		if v.SecretAccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.SecretAccessKey)
				if err == nil {
					seValues["secret_store_secret_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_secret_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["secret_access_key"] = v.SecretAccessKey
			}
		}
		d.Set("aws_console_static_key_pair", []map[string]interface{}{
			{
				"access_key":                           seValues["access_key"],
				"secret_store_access_key_path":         seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":          seValues["secret_store_access_key_key"],
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"region":                               (v.Region),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"role_arn":                             seValues["role_arn"],
				"secret_store_role_arn_path":           seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":            seValues["secret_store_role_arn_key"],
				"role_external_id":                     seValues["role_external_id"],
				"secret_store_role_external_id_path":   seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":    seValues["secret_store_role_external_id_key"],
				"secret_access_key":                    seValues["secret_access_key"],
				"secret_store_secret_access_key_path":  seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":   seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                      (v.SecretStoreID),
				"session_expiry":                       (v.SessionExpiry),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Azure:
		localV, ok := localVersion.(*sdm.Azure)
		if !ok {
			localV = &sdm.Azure{}
		}
		_ = localV
		if v.AppID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AppID)
				if err == nil {
					seValues["secret_store_app_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_app_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["app_id"] = v.AppID
			}
		}
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.TenantID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.TenantID)
				if err == nil {
					seValues["secret_store_tenant_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_tenant_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["tenant_id"] = v.TenantID
			}
		}
		d.Set("azure", []map[string]interface{}{
			{
				"app_id":                      seValues["app_id"],
				"secret_store_app_id_path":    seValues["secret_store_app_id_path"],
				"secret_store_app_id_key":     seValues["secret_store_app_id_key"],
				"bind_interface":              (v.BindInterface),
				"egress_filter":               (v.EgressFilter),
				"name":                        (v.Name),
				"password":                    seValues["password"],
				"secret_store_password_path":  seValues["secret_store_password_path"],
				"secret_store_password_key":   seValues["secret_store_password_key"],
				"port_override":               (v.PortOverride),
				"secret_store_id":             (v.SecretStoreID),
				"subdomain":                   (v.Subdomain),
				"tags":                        convertTagsToPorcelain(v.Tags),
				"tenant_id":                   seValues["tenant_id"],
				"secret_store_tenant_id_path": seValues["secret_store_tenant_id_path"],
				"secret_store_tenant_id_key":  seValues["secret_store_tenant_id_key"],
			},
		})
	case *sdm.AzureCertificate:
		localV, ok := localVersion.(*sdm.AzureCertificate)
		if !ok {
			localV = &sdm.AzureCertificate{}
		}
		_ = localV
		if v.AppID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AppID)
				if err == nil {
					seValues["secret_store_app_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_app_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["app_id"] = v.AppID
			}
		}
		if v.ClientCertificate != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientCertificate)
				if err == nil {
					seValues["secret_store_client_certificate_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_certificate_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_certificate"] = v.ClientCertificate
			}
		}
		if v.TenantID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.TenantID)
				if err == nil {
					seValues["secret_store_tenant_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_tenant_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["tenant_id"] = v.TenantID
			}
		}
		d.Set("azure_certificate", []map[string]interface{}{
			{
				"app_id":                               seValues["app_id"],
				"secret_store_app_id_path":             seValues["secret_store_app_id_path"],
				"secret_store_app_id_key":              seValues["secret_store_app_id_key"],
				"bind_interface":                       (v.BindInterface),
				"client_certificate":                   seValues["client_certificate"],
				"secret_store_client_certificate_path": seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":  seValues["secret_store_client_certificate_key"],
				"egress_filter":                        (v.EgressFilter),
				"name":                                 (v.Name),
				"port_override":                        (v.PortOverride),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"tenant_id":                            seValues["tenant_id"],
				"secret_store_tenant_id_path":          seValues["secret_store_tenant_id_path"],
				"secret_store_tenant_id_key":           seValues["secret_store_tenant_id_key"],
			},
		})
	case *sdm.AzureMysql:
		localV, ok := localVersion.(*sdm.AzureMysql)
		if !ok {
			localV = &sdm.AzureMysql{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("azure_mysql", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AzurePostgres:
		localV, ok := localVersion.(*sdm.AzurePostgres)
		if !ok {
			localV = &sdm.AzurePostgres{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("azure_postgres", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.BigQuery:
		localV, ok := localVersion.(*sdm.BigQuery)
		if !ok {
			localV = &sdm.BigQuery{}
		}
		_ = localV
		if v.PrivateKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.PrivateKey)
				if err == nil {
					seValues["secret_store_private_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_private_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["private_key"] = v.PrivateKey
			}
		}
		d.Set("big_query", []map[string]interface{}{
			{
				"bind_interface":                (v.BindInterface),
				"egress_filter":                 (v.EgressFilter),
				"endpoint":                      (v.Endpoint),
				"name":                          (v.Name),
				"port_override":                 (v.PortOverride),
				"private_key":                   seValues["private_key"],
				"secret_store_private_key_path": seValues["secret_store_private_key_path"],
				"secret_store_private_key_key":  seValues["secret_store_private_key_key"],
				"project":                       (v.Project),
				"secret_store_id":               (v.SecretStoreID),
				"subdomain":                     (v.Subdomain),
				"tags":                          convertTagsToPorcelain(v.Tags),
				"username":                      (v.Username),
			},
		})
	case *sdm.Cassandra:
		localV, ok := localVersion.(*sdm.Cassandra)
		if !ok {
			localV = &sdm.Cassandra{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("cassandra", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Citus:
		localV, ok := localVersion.(*sdm.Citus)
		if !ok {
			localV = &sdm.Citus{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("citus", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Clustrix:
		localV, ok := localVersion.(*sdm.Clustrix)
		if !ok {
			localV = &sdm.Clustrix{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("clustrix", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Cockroach:
		localV, ok := localVersion.(*sdm.Cockroach)
		if !ok {
			localV = &sdm.Cockroach{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("cockroach", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DB2I:
		localV, ok := localVersion.(*sdm.DB2I)
		if !ok {
			localV = &sdm.DB2I{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("db_2_i", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DB2LUW:
		localV, ok := localVersion.(*sdm.DB2LUW)
		if !ok {
			localV = &sdm.DB2LUW{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("db_2_luw", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DocumentDBHost:
		localV, ok := localVersion.(*sdm.DocumentDBHost)
		if !ok {
			localV = &sdm.DocumentDBHost{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("document_db_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DocumentDBReplicaSet:
		localV, ok := localVersion.(*sdm.DocumentDBReplicaSet)
		if !ok {
			localV = &sdm.DocumentDBReplicaSet{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("document_db_replica_set", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Druid:
		localV, ok := localVersion.(*sdm.Druid)
		if !ok {
			localV = &sdm.Druid{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("druid", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DynamoDB:
		localV, ok := localVersion.(*sdm.DynamoDB)
		if !ok {
			localV = &sdm.DynamoDB{}
		}
		_ = localV
		if v.AccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AccessKey)
				if err == nil {
					seValues["secret_store_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["access_key"] = v.AccessKey
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		if v.SecretAccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.SecretAccessKey)
				if err == nil {
					seValues["secret_store_secret_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_secret_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["secret_access_key"] = v.SecretAccessKey
			}
		}
		d.Set("dynamo_db", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Elastic:
		localV, ok := localVersion.(*sdm.Elastic)
		if !ok {
			localV = &sdm.Elastic{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("elastic", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.ElasticacheRedis:
		localV, ok := localVersion.(*sdm.ElasticacheRedis)
		if !ok {
			localV = &sdm.ElasticacheRedis{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("elasticache_redis", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.GCP:
		localV, ok := localVersion.(*sdm.GCP)
		if !ok {
			localV = &sdm.GCP{}
		}
		_ = localV
		if v.Keyfile != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Keyfile)
				if err == nil {
					seValues["secret_store_keyfile_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_keyfile_key"] = u.Query().Get("key")
				}
			} else {
				seValues["keyfile"] = v.Keyfile
			}
		}
		d.Set("gcp", []map[string]interface{}{
			{
				"bind_interface":            (v.BindInterface),
				"egress_filter":             (v.EgressFilter),
				"keyfile":                   seValues["keyfile"],
				"secret_store_keyfile_path": seValues["secret_store_keyfile_path"],
				"secret_store_keyfile_key":  seValues["secret_store_keyfile_key"],
				"name":                      (v.Name),
				"port_override":             (v.PortOverride),
				"scopes":                    (v.Scopes),
				"secret_store_id":           (v.SecretStoreID),
				"subdomain":                 (v.Subdomain),
				"tags":                      convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GoogleGKE:
		localV, ok := localVersion.(*sdm.GoogleGKE)
		if !ok {
			localV = &sdm.GoogleGKE{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.ServiceAccountKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ServiceAccountKey)
				if err == nil {
					seValues["secret_store_service_account_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_service_account_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["service_account_key"] = v.ServiceAccountKey
			}
		}
		d.Set("google_gke", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                         (v.SecretStoreID),
				"service_account_key":                     seValues["service_account_key"],
				"secret_store_service_account_key_path":   seValues["secret_store_service_account_key_path"],
				"secret_store_service_account_key_key":    seValues["secret_store_service_account_key_key"],
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.GoogleGKEUserImpersonation:
		localV, ok := localVersion.(*sdm.GoogleGKEUserImpersonation)
		if !ok {
			localV = &sdm.GoogleGKEUserImpersonation{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.ServiceAccountKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ServiceAccountKey)
				if err == nil {
					seValues["secret_store_service_account_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_service_account_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["service_account_key"] = v.ServiceAccountKey
			}
		}
		d.Set("google_gke_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"secret_store_id":                         (v.SecretStoreID),
				"service_account_key":                     seValues["service_account_key"],
				"secret_store_service_account_key_path":   seValues["secret_store_service_account_key_path"],
				"secret_store_service_account_key_key":    seValues["secret_store_service_account_key_key"],
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Greenplum:
		localV, ok := localVersion.(*sdm.Greenplum)
		if !ok {
			localV = &sdm.Greenplum{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("greenplum", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.HTTPAuth:
		localV, ok := localVersion.(*sdm.HTTPAuth)
		if !ok {
			localV = &sdm.HTTPAuth{}
		}
		_ = localV
		if v.AuthHeader != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AuthHeader)
				if err == nil {
					seValues["secret_store_auth_header_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_auth_header_key"] = u.Query().Get("key")
				}
			} else {
				seValues["auth_header"] = v.AuthHeader
			}
		}
		d.Set("http_auth", []map[string]interface{}{
			{
				"auth_header":                   seValues["auth_header"],
				"secret_store_auth_header_path": seValues["secret_store_auth_header_path"],
				"secret_store_auth_header_key":  seValues["secret_store_auth_header_key"],
				"bind_interface":                (v.BindInterface),
				"default_path":                  (v.DefaultPath),
				"egress_filter":                 (v.EgressFilter),
				"headers_blacklist":             (v.HeadersBlacklist),
				"healthcheck_path":              (v.HealthcheckPath),
				"host_override":                 (v.HostOverride),
				"name":                          (v.Name),
				"secret_store_id":               (v.SecretStoreID),
				"subdomain":                     (v.Subdomain),
				"tags":                          convertTagsToPorcelain(v.Tags),
				"url":                           (v.Url),
			},
		})
	case *sdm.HTTPBasicAuth:
		localV, ok := localVersion.(*sdm.HTTPBasicAuth)
		if !ok {
			localV = &sdm.HTTPBasicAuth{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("http_basic_auth", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"default_path":               (v.DefaultPath),
				"egress_filter":              (v.EgressFilter),
				"headers_blacklist":          (v.HeadersBlacklist),
				"healthcheck_path":           (v.HealthcheckPath),
				"host_override":              (v.HostOverride),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"url":                        (v.Url),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.HTTPNoAuth:
		localV, ok := localVersion.(*sdm.HTTPNoAuth)
		if !ok {
			localV = &sdm.HTTPNoAuth{}
		}
		_ = localV
		d.Set("http_no_auth", []map[string]interface{}{
			{
				"bind_interface":    (v.BindInterface),
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"host_override":     (v.HostOverride),
				"name":              (v.Name),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToPorcelain(v.Tags),
				"url":               (v.Url),
			},
		})
	case *sdm.Kubernetes:
		localV, ok := localVersion.(*sdm.Kubernetes)
		if !ok {
			localV = &sdm.Kubernetes{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.ClientCertificate != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientCertificate)
				if err == nil {
					seValues["secret_store_client_certificate_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_certificate_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_certificate"] = v.ClientCertificate
			}
		}
		if v.ClientKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientKey)
				if err == nil {
					seValues["secret_store_client_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_key"] = v.ClientKey
			}
		}
		d.Set("kubernetes", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"remote_identity_group_id":                (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username":    (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.KubernetesBasicAuth:
		localV, ok := localVersion.(*sdm.KubernetesBasicAuth)
		if !ok {
			localV = &sdm.KubernetesBasicAuth{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("kubernetes_basic_auth", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"healthcheck_namespace":      (v.HealthcheckNamespace),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.KubernetesServiceAccount:
		localV, ok := localVersion.(*sdm.KubernetesServiceAccount)
		if !ok {
			localV = &sdm.KubernetesServiceAccount{}
		}
		_ = localV
		if v.Token != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Token)
				if err == nil {
					seValues["secret_store_token_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_token_key"] = u.Query().Get("key")
				}
			} else {
				seValues["token"] = v.Token
			}
		}
		d.Set("kubernetes_service_account", []map[string]interface{}{
			{
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"healthcheck_namespace":                (v.HealthcheckNamespace),
				"hostname":                             (v.Hostname),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"token":                                seValues["token"],
				"secret_store_token_path":              seValues["secret_store_token_path"],
				"secret_store_token_key":               seValues["secret_store_token_key"],
			},
		})
	case *sdm.KubernetesServiceAccountUserImpersonation:
		localV, ok := localVersion.(*sdm.KubernetesServiceAccountUserImpersonation)
		if !ok {
			localV = &sdm.KubernetesServiceAccountUserImpersonation{}
		}
		_ = localV
		if v.Token != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Token)
				if err == nil {
					seValues["secret_store_token_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_token_key"] = u.Query().Get("key")
				}
			} else {
				seValues["token"] = v.Token
			}
		}
		d.Set("kubernetes_service_account_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":          (v.BindInterface),
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"port_override":           (v.PortOverride),
				"secret_store_id":         (v.SecretStoreID),
				"subdomain":               (v.Subdomain),
				"tags":                    convertTagsToPorcelain(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.KubernetesUserImpersonation:
		localV, ok := localVersion.(*sdm.KubernetesUserImpersonation)
		if !ok {
			localV = &sdm.KubernetesUserImpersonation{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.ClientCertificate != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientCertificate)
				if err == nil {
					seValues["secret_store_client_certificate_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_certificate_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_certificate"] = v.ClientCertificate
			}
		}
		if v.ClientKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientKey)
				if err == nil {
					seValues["secret_store_client_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_key"] = v.ClientKey
			}
		}
		d.Set("kubernetes_user_impersonation", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"secret_store_id":                         (v.SecretStoreID),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Maria:
		localV, ok := localVersion.(*sdm.Maria)
		if !ok {
			localV = &sdm.Maria{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("maria", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Memcached:
		localV, ok := localVersion.(*sdm.Memcached)
		if !ok {
			localV = &sdm.Memcached{}
		}
		_ = localV
		d.Set("memcached", []map[string]interface{}{
			{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Memsql:
		localV, ok := localVersion.(*sdm.Memsql)
		if !ok {
			localV = &sdm.Memsql{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("memsql", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoHost:
		localV, ok := localVersion.(*sdm.MongoHost)
		if !ok {
			localV = &sdm.MongoHost{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("mongo_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoLegacyHost:
		localV, ok := localVersion.(*sdm.MongoLegacyHost)
		if !ok {
			localV = &sdm.MongoLegacyHost{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("mongo_legacy_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoLegacyReplicaset:
		localV, ok := localVersion.(*sdm.MongoLegacyReplicaset)
		if !ok {
			localV = &sdm.MongoLegacyReplicaset{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("mongo_legacy_replicaset", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoReplicaSet:
		localV, ok := localVersion.(*sdm.MongoReplicaSet)
		if !ok {
			localV = &sdm.MongoReplicaSet{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("mongo_replica_set", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoShardedCluster:
		localV, ok := localVersion.(*sdm.MongoShardedCluster)
		if !ok {
			localV = &sdm.MongoShardedCluster{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("mongo_sharded_cluster", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MTLSMysql:
		localV, ok := localVersion.(*sdm.MTLSMysql)
		if !ok {
			localV = &sdm.MTLSMysql{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.ClientCertificate != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientCertificate)
				if err == nil {
					seValues["secret_store_client_certificate_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_certificate_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_certificate"] = v.ClientCertificate
			}
		}
		if v.ClientKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientKey)
				if err == nil {
					seValues["secret_store_client_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_key"] = v.ClientKey
			}
		}
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("mtls_mysql", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"database":                                (v.Database),
				"egress_filter":                           (v.EgressFilter),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"password":                                seValues["password"],
				"secret_store_password_path":              seValues["secret_store_password_path"],
				"secret_store_password_key":               seValues["secret_store_password_key"],
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"secret_store_id":                         (v.SecretStoreID),
				"server_name":                             (v.ServerName),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
				"username":                                seValues["username"],
				"secret_store_username_path":              seValues["secret_store_username_path"],
				"secret_store_username_key":               seValues["secret_store_username_key"],
			},
		})
	case *sdm.MTLSPostgres:
		localV, ok := localVersion.(*sdm.MTLSPostgres)
		if !ok {
			localV = &sdm.MTLSPostgres{}
		}
		_ = localV
		if v.CertificateAuthority != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.CertificateAuthority)
				if err == nil {
					seValues["secret_store_certificate_authority_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_certificate_authority_key"] = u.Query().Get("key")
				}
			} else {
				seValues["certificate_authority"] = v.CertificateAuthority
			}
		}
		if v.ClientCertificate != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientCertificate)
				if err == nil {
					seValues["secret_store_client_certificate_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_certificate_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_certificate"] = v.ClientCertificate
			}
		}
		if v.ClientKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.ClientKey)
				if err == nil {
					seValues["secret_store_client_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_client_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["client_key"] = v.ClientKey
			}
		}
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("mtls_postgres", []map[string]interface{}{
			{
				"bind_interface":                          (v.BindInterface),
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"database":                                (v.Database),
				"egress_filter":                           (v.EgressFilter),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"override_database":                       (v.OverrideDatabase),
				"password":                                seValues["password"],
				"secret_store_password_path":              seValues["secret_store_password_path"],
				"secret_store_password_key":               seValues["secret_store_password_key"],
				"port":                                    (v.Port),
				"port_override":                           (v.PortOverride),
				"secret_store_id":                         (v.SecretStoreID),
				"server_name":                             (v.ServerName),
				"subdomain":                               (v.Subdomain),
				"tags":                                    convertTagsToPorcelain(v.Tags),
				"username":                                seValues["username"],
				"secret_store_username_path":              seValues["secret_store_username_path"],
				"secret_store_username_key":               seValues["secret_store_username_key"],
			},
		})
	case *sdm.Mysql:
		localV, ok := localVersion.(*sdm.Mysql)
		if !ok {
			localV = &sdm.Mysql{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("mysql", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Neptune:
		localV, ok := localVersion.(*sdm.Neptune)
		if !ok {
			localV = &sdm.Neptune{}
		}
		_ = localV
		d.Set("neptune", []map[string]interface{}{
			{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"endpoint":        (v.Endpoint),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.NeptuneIAM:
		localV, ok := localVersion.(*sdm.NeptuneIAM)
		if !ok {
			localV = &sdm.NeptuneIAM{}
		}
		_ = localV
		if v.AccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.AccessKey)
				if err == nil {
					seValues["secret_store_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["access_key"] = v.AccessKey
			}
		}
		if v.RoleArn != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleArn)
				if err == nil {
					seValues["secret_store_role_arn_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_arn_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_arn"] = v.RoleArn
			}
		}
		if v.RoleExternalID != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.RoleExternalID)
				if err == nil {
					seValues["secret_store_role_external_id_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_role_external_id_key"] = u.Query().Get("key")
				}
			} else {
				seValues["role_external_id"] = v.RoleExternalID
			}
		}
		if v.SecretAccessKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.SecretAccessKey)
				if err == nil {
					seValues["secret_store_secret_access_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_secret_access_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["secret_access_key"] = v.SecretAccessKey
			}
		}
		d.Set("neptune_iam", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"bind_interface":                      (v.BindInterface),
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"subdomain":                           (v.Subdomain),
				"tags":                                convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.Oracle:
		localV, ok := localVersion.(*sdm.Oracle)
		if !ok {
			localV = &sdm.Oracle{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("oracle", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Postgres:
		localV, ok := localVersion.(*sdm.Postgres)
		if !ok {
			localV = &sdm.Postgres{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("postgres", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Presto:
		localV, ok := localVersion.(*sdm.Presto)
		if !ok {
			localV = &sdm.Presto{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		d.Set("presto", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   (v.Username),
			},
		})
	case *sdm.RabbitMQAMQP091:
		localV, ok := localVersion.(*sdm.RabbitMQAMQP091)
		if !ok {
			localV = &sdm.RabbitMQAMQP091{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("rabbitmq_amqp_091", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.RawTCP:
		localV, ok := localVersion.(*sdm.RawTCP)
		if !ok {
			localV = &sdm.RawTCP{}
		}
		_ = localV
		d.Set("raw_tcp", []map[string]interface{}{
			{
				"bind_interface":  (v.BindInterface),
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"subdomain":       (v.Subdomain),
				"tags":            convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.RDP:
		localV, ok := localVersion.(*sdm.RDP)
		if !ok {
			localV = &sdm.RDP{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("rdp", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"downgrade_nla_connections":  (v.DowngradeNlaConnections),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Redis:
		localV, ok := localVersion.(*sdm.Redis)
		if !ok {
			localV = &sdm.Redis{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("redis", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Redshift:
		localV, ok := localVersion.(*sdm.Redshift)
		if !ok {
			localV = &sdm.Redshift{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("redshift", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SingleStore:
		localV, ok := localVersion.(*sdm.SingleStore)
		if !ok {
			localV = &sdm.SingleStore{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("single_store", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Snowflake:
		localV, ok := localVersion.(*sdm.Snowflake)
		if !ok {
			localV = &sdm.Snowflake{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("snowflake", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"schema":                     (v.Schema),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Snowsight:
		localV, ok := localVersion.(*sdm.Snowsight)
		if !ok {
			localV = &sdm.Snowsight{}
		}
		_ = localV
		if v.SamlMetadata != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.SamlMetadata)
				if err == nil {
					seValues["secret_store_saml_metadata_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_saml_metadata_key"] = u.Query().Get("key")
				}
			} else {
				seValues["saml_metadata"] = v.SamlMetadata
			}
		}
		d.Set("snowsight", []map[string]interface{}{
			{
				"bind_interface":                  (v.BindInterface),
				"egress_filter":                   (v.EgressFilter),
				"healthcheck_username":            (v.HealthcheckUsername),
				"name":                            (v.Name),
				"port_override":                   (v.PortOverride),
				"saml_metadata":                   seValues["saml_metadata"],
				"secret_store_saml_metadata_path": seValues["secret_store_saml_metadata_path"],
				"secret_store_saml_metadata_key":  seValues["secret_store_saml_metadata_key"],
				"secret_store_id":                 (v.SecretStoreID),
				"subdomain":                       (v.Subdomain),
				"tags":                            convertTagsToPorcelain(v.Tags),
			},
		})
	case *sdm.SQLServer:
		localV, ok := localVersion.(*sdm.SQLServer)
		if !ok {
			localV = &sdm.SQLServer{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("sql_server", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"schema":                     (v.Schema),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSH:
		localV, ok := localVersion.(*sdm.SSH)
		if !ok {
			localV = &sdm.SSH{}
		}
		_ = localV
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("ssh", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"key_type":                       (v.KeyType),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"public_key":                     (v.PublicKey),
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSHCert:
		localV, ok := localVersion.(*sdm.SSHCert)
		if !ok {
			localV = &sdm.SSHCert{}
		}
		_ = localV
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("ssh_cert", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges":       (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                       (v.BindInterface),
				"egress_filter":                        (v.EgressFilter),
				"hostname":                             (v.Hostname),
				"key_type":                             (v.KeyType),
				"name":                                 (v.Name),
				"port":                                 (v.Port),
				"port_forwarding":                      (v.PortForwarding),
				"port_override":                        (v.PortOverride),
				"remote_identity_group_id":             (v.RemoteIdentityGroupID),
				"remote_identity_healthcheck_username": (v.RemoteIdentityHealthcheckUsername),
				"secret_store_id":                      (v.SecretStoreID),
				"subdomain":                            (v.Subdomain),
				"tags":                                 convertTagsToPorcelain(v.Tags),
				"username":                             seValues["username"],
				"secret_store_username_path":           seValues["secret_store_username_path"],
				"secret_store_username_key":            seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSHCustomerKey:
		localV, ok := localVersion.(*sdm.SSHCustomerKey)
		if !ok {
			localV = &sdm.SSHCustomerKey{}
		}
		_ = localV
		if v.PrivateKey != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.PrivateKey)
				if err == nil {
					seValues["secret_store_private_key_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_private_key_key"] = u.Query().Get("key")
				}
			} else {
				seValues["private_key"] = v.PrivateKey
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("ssh_customer_key", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"bind_interface":                 (v.BindInterface),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"port_override":                  (v.PortOverride),
				"private_key":                    seValues["private_key"],
				"secret_store_private_key_path":  seValues["secret_store_private_key_path"],
				"secret_store_private_key_key":   seValues["secret_store_private_key_key"],
				"secret_store_id":                (v.SecretStoreID),
				"subdomain":                      (v.Subdomain),
				"tags":                           convertTagsToPorcelain(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.Sybase:
		localV, ok := localVersion.(*sdm.Sybase)
		if !ok {
			localV = &sdm.Sybase{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("sybase", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SybaseIQ:
		localV, ok := localVersion.(*sdm.SybaseIQ)
		if !ok {
			localV = &sdm.SybaseIQ{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("sybase_iq", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Teradata:
		localV, ok := localVersion.(*sdm.Teradata)
		if !ok {
			localV = &sdm.Teradata{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		if v.Username != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Username)
				if err == nil {
					seValues["secret_store_username_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_username_key"] = u.Query().Get("key")
				}
			} else {
				seValues["username"] = v.Username
			}
		}
		d.Set("teradata", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Trino:
		localV, ok := localVersion.(*sdm.Trino)
		if !ok {
			localV = &sdm.Trino{}
		}
		_ = localV
		if v.Password != "" {
			if v.SecretStoreID != "" {
				u, err := url.ParseRequestURI("secretstore://store/" + v.Password)
				if err == nil {
					seValues["secret_store_password_path"] = strings.TrimPrefix(u.Path, "/")
					seValues["secret_store_password_key"] = u.Query().Get("key")
				}
			} else {
				seValues["password"] = v.Password
			}
		}
		d.Set("trino", []map[string]interface{}{
			{
				"bind_interface":             (v.BindInterface),
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToPorcelain(v.Tags),
				"username":                   (v.Username),
			},
		})
	}
	return nil
}
func resourceResourceUpdate(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	_, err := secretStoreValuesForResource(d)
	if err != nil {
		return fmt.Errorf("cannot update Resource %s: %w", d.Id(), err)
	}
	resp, err := cc.Resources().Update(ctx, convertResourceToPlumbing(d))
	if err != nil {
		return fmt.Errorf("cannot update Resource %s: %w", d.Id(), err)
	}
	d.SetId(resp.Resource.GetID())
	return resourceResourceRead(ctx, d, cc)
}
func resourceResourceDelete(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	var errNotFound *sdm.NotFoundError
	_, err := cc.Resources().Delete(ctx, d.Id())
	if err != nil && errors.As(err, &errNotFound) {
		return nil
	}
	return err
}
