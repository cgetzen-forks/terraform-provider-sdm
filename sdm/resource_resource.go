// This file was generated by protogen. DO NOT EDIT.

package sdm

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	sdm "github.com/strongdm/terraform-provider-sdm/sdm/internal/sdk"
)

func resourceResource() *schema.Resource {
	return &schema.Resource{
		CreateContext: wrapCrudOperation(resourceResourceCreate),
		ReadContext:   wrapCrudOperation(resourceResourceRead),
		UpdateContext: wrapCrudOperation(resourceResourceUpdate),
		DeleteContext: wrapCrudOperation(resourceResourceDelete),
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"aks": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aks_basic_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aks_service_account": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_token_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_token_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aks_service_account_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_token_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_token_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aks_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_eks_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazon_es": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"amazonmq_amqp_091": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"athena": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"output": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"aurora_mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aurora_postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"aws": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"azure": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_app_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_app_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tenant_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_tenant_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_tenant_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"azure_certificate": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_app_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_app_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tenant_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_tenant_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_tenant_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"azure_postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"big_query": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"private_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_private_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_private_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"project": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"cassandra": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"citus": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"clustrix": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"cockroach": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"db_2_i": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"db_2_luw": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"document_db_host": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"document_db_replica_set": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"druid": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"dynamo_db": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"elastic": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"elasticache_redis": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"gcp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"keyfile": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_keyfile_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_keyfile_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"scopes": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"google_gke": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"service_account_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_service_account_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_service_account_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"google_gke_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"service_account_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_service_account_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_service_account_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"greenplum": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"http_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_header": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_auth_header_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_auth_header_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
					},
				},
			},
			"http_basic_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"http_no_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"default_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"headers_blacklist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"healthcheck_path": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"subdomain": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
					},
				},
			},
			"kubernetes": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"kubernetes_basic_auth": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"kubernetes_service_account": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_token_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_token_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"kubernetes_service_account_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"token": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_token_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_token_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"kubernetes_user_impersonation": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"certificate_authority": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_certificate_authority_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_certificate_authority_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_certificate": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_certificate_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_certificate_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"client_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_client_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_client_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"healthcheck_namespace": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The path used to check the health of your connection.  Defaults to `default`.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"maria": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"memcached": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"memsql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_host": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_legacy_host": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_legacy_replicaset": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_replica_set": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"connect_to_replica": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"replica_set": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mongo_sharded_cluster": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"mysql": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"neptune": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"neptune_iam": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"endpoint": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"role_arn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_arn_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_arn_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"role_external_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_role_external_id_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_role_external_id_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_access_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_secret_access_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_secret_access_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"oracle": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"postgres": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"presto": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
					},
				},
			},
			"rabbitmq_amqp_091": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"tls_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"raw_tcp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"rdp": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"downgrade_nla_connections": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"redis": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
					},
				},
			},
			"redshift": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"single_store": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"snowflake": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"schema": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"sql_server": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"override_database": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"schema": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"ssh": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"public_key": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"ssh_cert": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"ssh_customer_key": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_deprecated_key_exchanges": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"port": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "",
						},
						"port_forwarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
						},
						"private_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_private_key_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_private_key_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"sybase": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"sybase_iq": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
			"teradata": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_filter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "A filter applied to the routing logic to pin datasource to nodes.",
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "",
						},
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Unique human-readable name of the Resource.",
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Sensitive:   true,
							Description: "",
						},
						"secret_store_password_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_password_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "",
						},
						"port_override": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "",
						},
						"secret_store_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "ID of the secret store containing credentials for this resource, if any.",
						},
						"tags": {
							Type:        schema.TypeMap,
							Elem:        tagsElemType,
							Optional:    true,
							Description: "Tags is a map of key, value pairs.",
						},
						"username": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "",
						},
						"secret_store_username_path": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"secret_store_username_key": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
		},
		Timeouts: &schema.ResourceTimeout{
			Default: schema.DefaultTimeout(60 * time.Second),
		},
	}
}
func secretStoreValuesForResource(d *schema.ResourceData) (map[string]string, error) {
	if list := d.Get("aks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringFromMap(raw, "certificate_authority"),
			"secret_store_certificate_authority_path": convertStringFromMap(raw, "secret_store_certificate_authority_path"),
			"secret_store_certificate_authority_key":  convertStringFromMap(raw, "secret_store_certificate_authority_key"),
			"client_certificate":                      convertStringFromMap(raw, "client_certificate"),
			"secret_store_client_certificate_path":    convertStringFromMap(raw, "secret_store_client_certificate_path"),
			"secret_store_client_certificate_key":     convertStringFromMap(raw, "secret_store_client_certificate_key"),
			"client_key":                              convertStringFromMap(raw, "client_key"),
			"secret_store_client_key_path":            convertStringFromMap(raw, "secret_store_client_key_path"),
			"secret_store_client_key_key":             convertStringFromMap(raw, "secret_store_client_key_key"),
		}, nil
	}
	if list := d.Get("aks_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("aks_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential token cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_token_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_token_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"token":                   convertStringFromMap(raw, "token"),
			"secret_store_token_path": convertStringFromMap(raw, "secret_store_token_path"),
			"secret_store_token_key":  convertStringFromMap(raw, "secret_store_token_key"),
		}, nil
	}
	if list := d.Get("aks_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential token cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_token_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_token_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"token":                   convertStringFromMap(raw, "token"),
			"secret_store_token_path": convertStringFromMap(raw, "secret_store_token_path"),
			"secret_store_token_key":  convertStringFromMap(raw, "secret_store_token_key"),
		}, nil
	}
	if list := d.Get("aks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringFromMap(raw, "certificate_authority"),
			"secret_store_certificate_authority_path": convertStringFromMap(raw, "secret_store_certificate_authority_path"),
			"secret_store_certificate_authority_key":  convertStringFromMap(raw, "secret_store_certificate_authority_key"),
			"client_certificate":                      convertStringFromMap(raw, "client_certificate"),
			"secret_store_client_certificate_path":    convertStringFromMap(raw, "secret_store_client_certificate_path"),
			"secret_store_client_certificate_key":     convertStringFromMap(raw, "secret_store_client_certificate_key"),
			"client_key":                              convertStringFromMap(raw, "client_key"),
			"secret_store_client_key_path":            convertStringFromMap(raw, "secret_store_client_key_path"),
			"secret_store_client_key_key":             convertStringFromMap(raw, "secret_store_client_key_key"),
		}, nil
	}
	if list := d.Get("amazon_eks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                              convertStringFromMap(raw, "access_key"),
			"secret_store_access_key_path":            convertStringFromMap(raw, "secret_store_access_key_path"),
			"secret_store_access_key_key":             convertStringFromMap(raw, "secret_store_access_key_key"),
			"certificate_authority":                   convertStringFromMap(raw, "certificate_authority"),
			"secret_store_certificate_authority_path": convertStringFromMap(raw, "secret_store_certificate_authority_path"),
			"secret_store_certificate_authority_key":  convertStringFromMap(raw, "secret_store_certificate_authority_key"),
			"role_arn":                                convertStringFromMap(raw, "role_arn"),
			"secret_store_role_arn_path":              convertStringFromMap(raw, "secret_store_role_arn_path"),
			"secret_store_role_arn_key":               convertStringFromMap(raw, "secret_store_role_arn_key"),
			"role_external_id":                        convertStringFromMap(raw, "role_external_id"),
			"secret_store_role_external_id_path":      convertStringFromMap(raw, "secret_store_role_external_id_path"),
			"secret_store_role_external_id_key":       convertStringFromMap(raw, "secret_store_role_external_id_key"),
			"secret_access_key":                       convertStringFromMap(raw, "secret_access_key"),
			"secret_store_secret_access_key_path":     convertStringFromMap(raw, "secret_store_secret_access_key_path"),
			"secret_store_secret_access_key_key":      convertStringFromMap(raw, "secret_store_secret_access_key_key"),
		}, nil
	}
	if list := d.Get("amazon_eks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                              convertStringFromMap(raw, "access_key"),
			"secret_store_access_key_path":            convertStringFromMap(raw, "secret_store_access_key_path"),
			"secret_store_access_key_key":             convertStringFromMap(raw, "secret_store_access_key_key"),
			"certificate_authority":                   convertStringFromMap(raw, "certificate_authority"),
			"secret_store_certificate_authority_path": convertStringFromMap(raw, "secret_store_certificate_authority_path"),
			"secret_store_certificate_authority_key":  convertStringFromMap(raw, "secret_store_certificate_authority_key"),
			"role_arn":                                convertStringFromMap(raw, "role_arn"),
			"secret_store_role_arn_path":              convertStringFromMap(raw, "secret_store_role_arn_path"),
			"secret_store_role_arn_key":               convertStringFromMap(raw, "secret_store_role_arn_key"),
			"role_external_id":                        convertStringFromMap(raw, "role_external_id"),
			"secret_store_role_external_id_path":      convertStringFromMap(raw, "secret_store_role_external_id_path"),
			"secret_store_role_external_id_key":       convertStringFromMap(raw, "secret_store_role_external_id_key"),
			"secret_access_key":                       convertStringFromMap(raw, "secret_access_key"),
			"secret_store_secret_access_key_path":     convertStringFromMap(raw, "secret_store_secret_access_key_path"),
			"secret_store_secret_access_key_key":      convertStringFromMap(raw, "secret_store_secret_access_key_key"),
		}, nil
	}
	if list := d.Get("amazon_es").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringFromMap(raw, "access_key"),
			"secret_store_access_key_path":        convertStringFromMap(raw, "secret_store_access_key_path"),
			"secret_store_access_key_key":         convertStringFromMap(raw, "secret_store_access_key_key"),
			"role_arn":                            convertStringFromMap(raw, "role_arn"),
			"secret_store_role_arn_path":          convertStringFromMap(raw, "secret_store_role_arn_path"),
			"secret_store_role_arn_key":           convertStringFromMap(raw, "secret_store_role_arn_key"),
			"role_external_id":                    convertStringFromMap(raw, "role_external_id"),
			"secret_store_role_external_id_path":  convertStringFromMap(raw, "secret_store_role_external_id_path"),
			"secret_store_role_external_id_key":   convertStringFromMap(raw, "secret_store_role_external_id_key"),
			"secret_access_key":                   convertStringFromMap(raw, "secret_access_key"),
			"secret_store_secret_access_key_path": convertStringFromMap(raw, "secret_store_secret_access_key_path"),
			"secret_store_secret_access_key_key":  convertStringFromMap(raw, "secret_store_secret_access_key_key"),
		}, nil
	}
	if list := d.Get("amazonmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("athena").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringFromMap(raw, "access_key"),
			"secret_store_access_key_path":        convertStringFromMap(raw, "secret_store_access_key_path"),
			"secret_store_access_key_key":         convertStringFromMap(raw, "secret_store_access_key_key"),
			"role_arn":                            convertStringFromMap(raw, "role_arn"),
			"secret_store_role_arn_path":          convertStringFromMap(raw, "secret_store_role_arn_path"),
			"secret_store_role_arn_key":           convertStringFromMap(raw, "secret_store_role_arn_key"),
			"role_external_id":                    convertStringFromMap(raw, "role_external_id"),
			"secret_store_role_external_id_path":  convertStringFromMap(raw, "secret_store_role_external_id_path"),
			"secret_store_role_external_id_key":   convertStringFromMap(raw, "secret_store_role_external_id_key"),
			"secret_access_key":                   convertStringFromMap(raw, "secret_access_key"),
			"secret_store_secret_access_key_path": convertStringFromMap(raw, "secret_store_secret_access_key_path"),
			"secret_store_secret_access_key_key":  convertStringFromMap(raw, "secret_store_secret_access_key_key"),
		}, nil
	}
	if list := d.Get("aurora_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("aurora_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("aws").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringFromMap(raw, "access_key"),
			"secret_store_access_key_path":        convertStringFromMap(raw, "secret_store_access_key_path"),
			"secret_store_access_key_key":         convertStringFromMap(raw, "secret_store_access_key_key"),
			"role_arn":                            convertStringFromMap(raw, "role_arn"),
			"secret_store_role_arn_path":          convertStringFromMap(raw, "secret_store_role_arn_path"),
			"secret_store_role_arn_key":           convertStringFromMap(raw, "secret_store_role_arn_key"),
			"role_external_id":                    convertStringFromMap(raw, "role_external_id"),
			"secret_store_role_external_id_path":  convertStringFromMap(raw, "secret_store_role_external_id_path"),
			"secret_store_role_external_id_key":   convertStringFromMap(raw, "secret_store_role_external_id_key"),
			"secret_access_key":                   convertStringFromMap(raw, "secret_access_key"),
			"secret_store_secret_access_key_path": convertStringFromMap(raw, "secret_store_secret_access_key_path"),
			"secret_store_secret_access_key_key":  convertStringFromMap(raw, "secret_store_secret_access_key_key"),
		}, nil
	}
	if list := d.Get("azure").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["app_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential app_id cannot be combined with secret_store_id")
			}
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["tenant_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential tenant_id cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_app_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_app_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_app_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_app_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_tenant_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_tenant_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_tenant_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_tenant_id_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"app_id":                      convertStringFromMap(raw, "app_id"),
			"secret_store_app_id_path":    convertStringFromMap(raw, "secret_store_app_id_path"),
			"secret_store_app_id_key":     convertStringFromMap(raw, "secret_store_app_id_key"),
			"password":                    convertStringFromMap(raw, "password"),
			"secret_store_password_path":  convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":   convertStringFromMap(raw, "secret_store_password_key"),
			"tenant_id":                   convertStringFromMap(raw, "tenant_id"),
			"secret_store_tenant_id_path": convertStringFromMap(raw, "secret_store_tenant_id_path"),
			"secret_store_tenant_id_key":  convertStringFromMap(raw, "secret_store_tenant_id_key"),
		}, nil
	}
	if list := d.Get("azure_certificate").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["app_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential app_id cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["tenant_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential tenant_id cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_app_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_app_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_app_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_app_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_tenant_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_tenant_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_tenant_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_tenant_id_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"app_id":                               convertStringFromMap(raw, "app_id"),
			"secret_store_app_id_path":             convertStringFromMap(raw, "secret_store_app_id_path"),
			"secret_store_app_id_key":              convertStringFromMap(raw, "secret_store_app_id_key"),
			"client_certificate":                   convertStringFromMap(raw, "client_certificate"),
			"secret_store_client_certificate_path": convertStringFromMap(raw, "secret_store_client_certificate_path"),
			"secret_store_client_certificate_key":  convertStringFromMap(raw, "secret_store_client_certificate_key"),
			"tenant_id":                            convertStringFromMap(raw, "tenant_id"),
			"secret_store_tenant_id_path":          convertStringFromMap(raw, "secret_store_tenant_id_path"),
			"secret_store_tenant_id_key":           convertStringFromMap(raw, "secret_store_tenant_id_key"),
		}, nil
	}
	if list := d.Get("azure_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("big_query").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["private_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential private_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_private_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_private_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_private_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_private_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"private_key":                   convertStringFromMap(raw, "private_key"),
			"secret_store_private_key_path": convertStringFromMap(raw, "secret_store_private_key_path"),
			"secret_store_private_key_key":  convertStringFromMap(raw, "secret_store_private_key_key"),
		}, nil
	}
	if list := d.Get("cassandra").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("citus").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("clustrix").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("cockroach").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("db_2_i").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("db_2_luw").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("document_db_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("document_db_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("druid").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("dynamo_db").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringFromMap(raw, "access_key"),
			"secret_store_access_key_path":        convertStringFromMap(raw, "secret_store_access_key_path"),
			"secret_store_access_key_key":         convertStringFromMap(raw, "secret_store_access_key_key"),
			"role_arn":                            convertStringFromMap(raw, "role_arn"),
			"secret_store_role_arn_path":          convertStringFromMap(raw, "secret_store_role_arn_path"),
			"secret_store_role_arn_key":           convertStringFromMap(raw, "secret_store_role_arn_key"),
			"role_external_id":                    convertStringFromMap(raw, "role_external_id"),
			"secret_store_role_external_id_path":  convertStringFromMap(raw, "secret_store_role_external_id_path"),
			"secret_store_role_external_id_key":   convertStringFromMap(raw, "secret_store_role_external_id_key"),
			"secret_access_key":                   convertStringFromMap(raw, "secret_access_key"),
			"secret_store_secret_access_key_path": convertStringFromMap(raw, "secret_store_secret_access_key_path"),
			"secret_store_secret_access_key_key":  convertStringFromMap(raw, "secret_store_secret_access_key_key"),
		}, nil
	}
	if list := d.Get("elastic").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("elasticache_redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
		}, nil
	}
	if list := d.Get("gcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["keyfile"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential keyfile cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_keyfile_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_keyfile_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_keyfile_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_keyfile_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"keyfile":                   convertStringFromMap(raw, "keyfile"),
			"secret_store_keyfile_path": convertStringFromMap(raw, "secret_store_keyfile_path"),
			"secret_store_keyfile_key":  convertStringFromMap(raw, "secret_store_keyfile_key"),
		}, nil
	}
	if list := d.Get("google_gke").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["service_account_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential service_account_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_service_account_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_service_account_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_service_account_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_service_account_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringFromMap(raw, "certificate_authority"),
			"secret_store_certificate_authority_path": convertStringFromMap(raw, "secret_store_certificate_authority_path"),
			"secret_store_certificate_authority_key":  convertStringFromMap(raw, "secret_store_certificate_authority_key"),
			"service_account_key":                     convertStringFromMap(raw, "service_account_key"),
			"secret_store_service_account_key_path":   convertStringFromMap(raw, "secret_store_service_account_key_path"),
			"secret_store_service_account_key_key":    convertStringFromMap(raw, "secret_store_service_account_key_key"),
		}, nil
	}
	if list := d.Get("google_gke_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["service_account_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential service_account_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_service_account_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_service_account_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_service_account_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_service_account_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringFromMap(raw, "certificate_authority"),
			"secret_store_certificate_authority_path": convertStringFromMap(raw, "secret_store_certificate_authority_path"),
			"secret_store_certificate_authority_key":  convertStringFromMap(raw, "secret_store_certificate_authority_key"),
			"service_account_key":                     convertStringFromMap(raw, "service_account_key"),
			"secret_store_service_account_key_path":   convertStringFromMap(raw, "secret_store_service_account_key_path"),
			"secret_store_service_account_key_key":    convertStringFromMap(raw, "secret_store_service_account_key_key"),
		}, nil
	}
	if list := d.Get("greenplum").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("http_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["auth_header"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential auth_header cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_auth_header_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_auth_header_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_auth_header_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_auth_header_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"auth_header":                   convertStringFromMap(raw, "auth_header"),
			"secret_store_auth_header_path": convertStringFromMap(raw, "secret_store_auth_header_path"),
			"secret_store_auth_header_key":  convertStringFromMap(raw, "secret_store_auth_header_key"),
		}, nil
	}
	if list := d.Get("http_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("http_no_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		} else {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("kubernetes").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringFromMap(raw, "certificate_authority"),
			"secret_store_certificate_authority_path": convertStringFromMap(raw, "secret_store_certificate_authority_path"),
			"secret_store_certificate_authority_key":  convertStringFromMap(raw, "secret_store_certificate_authority_key"),
			"client_certificate":                      convertStringFromMap(raw, "client_certificate"),
			"secret_store_client_certificate_path":    convertStringFromMap(raw, "secret_store_client_certificate_path"),
			"secret_store_client_certificate_key":     convertStringFromMap(raw, "secret_store_client_certificate_key"),
			"client_key":                              convertStringFromMap(raw, "client_key"),
			"secret_store_client_key_path":            convertStringFromMap(raw, "secret_store_client_key_path"),
			"secret_store_client_key_key":             convertStringFromMap(raw, "secret_store_client_key_key"),
		}, nil
	}
	if list := d.Get("kubernetes_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("kubernetes_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential token cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_token_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_token_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"token":                   convertStringFromMap(raw, "token"),
			"secret_store_token_path": convertStringFromMap(raw, "secret_store_token_path"),
			"secret_store_token_key":  convertStringFromMap(raw, "secret_store_token_key"),
		}, nil
	}
	if list := d.Get("kubernetes_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["token"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential token cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_token_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_token_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_token_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"token":                   convertStringFromMap(raw, "token"),
			"secret_store_token_path": convertStringFromMap(raw, "secret_store_token_path"),
			"secret_store_token_key":  convertStringFromMap(raw, "secret_store_token_key"),
		}, nil
	}
	if list := d.Get("kubernetes_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["certificate_authority"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential certificate_authority cannot be combined with secret_store_id")
			}
			if v := raw["client_certificate"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_certificate cannot be combined with secret_store_id")
			}
			if v := raw["client_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential client_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_certificate_authority_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_certificate_authority_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_certificate_authority_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_certificate_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_certificate_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_client_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_client_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"certificate_authority":                   convertStringFromMap(raw, "certificate_authority"),
			"secret_store_certificate_authority_path": convertStringFromMap(raw, "secret_store_certificate_authority_path"),
			"secret_store_certificate_authority_key":  convertStringFromMap(raw, "secret_store_certificate_authority_key"),
			"client_certificate":                      convertStringFromMap(raw, "client_certificate"),
			"secret_store_client_certificate_path":    convertStringFromMap(raw, "secret_store_client_certificate_path"),
			"secret_store_client_certificate_key":     convertStringFromMap(raw, "secret_store_client_certificate_key"),
			"client_key":                              convertStringFromMap(raw, "client_key"),
			"secret_store_client_key_path":            convertStringFromMap(raw, "secret_store_client_key_path"),
			"secret_store_client_key_key":             convertStringFromMap(raw, "secret_store_client_key_key"),
		}, nil
	}
	if list := d.Get("maria").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("memcached").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		} else {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("memsql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("mongo_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("mongo_legacy_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("mongo_legacy_replicaset").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("mongo_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("mongo_sharded_cluster").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("neptune").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		} else {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("neptune_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential access_key cannot be combined with secret_store_id")
			}
			if v := raw["role_arn"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_arn cannot be combined with secret_store_id")
			}
			if v := raw["role_external_id"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential role_external_id cannot be combined with secret_store_id")
			}
			if v := raw["secret_access_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential secret_access_key cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_access_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_arn_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_arn_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_role_external_id_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_role_external_id_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_secret_access_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_secret_access_key_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"access_key":                          convertStringFromMap(raw, "access_key"),
			"secret_store_access_key_path":        convertStringFromMap(raw, "secret_store_access_key_path"),
			"secret_store_access_key_key":         convertStringFromMap(raw, "secret_store_access_key_key"),
			"role_arn":                            convertStringFromMap(raw, "role_arn"),
			"secret_store_role_arn_path":          convertStringFromMap(raw, "secret_store_role_arn_path"),
			"secret_store_role_arn_key":           convertStringFromMap(raw, "secret_store_role_arn_key"),
			"role_external_id":                    convertStringFromMap(raw, "role_external_id"),
			"secret_store_role_external_id_path":  convertStringFromMap(raw, "secret_store_role_external_id_path"),
			"secret_store_role_external_id_key":   convertStringFromMap(raw, "secret_store_role_external_id_key"),
			"secret_access_key":                   convertStringFromMap(raw, "secret_access_key"),
			"secret_store_secret_access_key_path": convertStringFromMap(raw, "secret_store_secret_access_key_path"),
			"secret_store_secret_access_key_key":  convertStringFromMap(raw, "secret_store_secret_access_key_key"),
		}, nil
	}
	if list := d.Get("oracle").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("presto").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
		}, nil
	}
	if list := d.Get("rabbitmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("raw_tcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
		} else {
		}

		return map[string]string{}, nil
	}
	if list := d.Get("rdp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
		}, nil
	}
	if list := d.Get("redshift").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("single_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("snowflake").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("sql_server").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("ssh_cert").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("ssh_customer_key").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["private_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential private_key cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_private_key_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_private_key_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_private_key_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_private_key_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"private_key":                   convertStringFromMap(raw, "private_key"),
			"secret_store_private_key_path": convertStringFromMap(raw, "secret_store_private_key_path"),
			"secret_store_private_key_key":  convertStringFromMap(raw, "secret_store_private_key_key"),
			"username":                      convertStringFromMap(raw, "username"),
			"secret_store_username_path":    convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":     convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("sybase").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("sybase_iq").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	if list := d.Get("teradata").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return map[string]string{}, nil
		}
		_ = raw
		if seID := raw["secret_store_id"]; seID != nil && seID.(string) != "" {
			if v := raw["password"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential password cannot be combined with secret_store_id")
			}
			if v := raw["username"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("raw credential username cannot be combined with secret_store_id")
			}
		} else {
			if v := raw["secret_store_password_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_password_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_password_key must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_path"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_path must be combined with secret_store_id")
			}
			if v := raw["secret_store_username_key"]; v != nil && v.(string) != "" {
				return nil, fmt.Errorf("secret store credential secret_store_username_key must be combined with secret_store_id")
			}
		}

		return map[string]string{
			"password":                   convertStringFromMap(raw, "password"),
			"secret_store_password_path": convertStringFromMap(raw, "secret_store_password_path"),
			"secret_store_password_key":  convertStringFromMap(raw, "secret_store_password_key"),
			"username":                   convertStringFromMap(raw, "username"),
			"secret_store_username_path": convertStringFromMap(raw, "secret_store_username_path"),
			"secret_store_username_key":  convertStringFromMap(raw, "secret_store_username_key"),
		}, nil
	}
	return map[string]string{}, nil
}
func convertResourceFromResourceData(d *schema.ResourceData) sdm.Resource {
	if list := d.Get("aks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKS{}
		}
		out := &sdm.AKS{
			ID:                   d.Id(),
			CertificateAuthority: convertStringFromMap(raw, "certificate_authority"),
			ClientCertificate:    convertStringFromMap(raw, "client_certificate"),
			ClientKey:            convertStringFromMap(raw, "client_key"),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		return out
	}
	if list := d.Get("aks_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSBasicAuth{}
		}
		out := &sdm.AKSBasicAuth{
			ID:                   d.Id(),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Password:             convertStringFromMap(raw, "password"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Username:             convertStringFromMap(raw, "username"),
		}
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("aks_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSServiceAccount{}
		}
		out := &sdm.AKSServiceAccount{
			ID:                   d.Id(),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Token:                convertStringFromMap(raw, "token"),
		}
		if out.Token == "" {
			out.Token = fullSecretStorePath(raw, "token")
		}
		return out
	}
	if list := d.Get("aks_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSServiceAccountUserImpersonation{}
		}
		out := &sdm.AKSServiceAccountUserImpersonation{
			ID:                   d.Id(),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Token:                convertStringFromMap(raw, "token"),
		}
		if out.Token == "" {
			out.Token = fullSecretStorePath(raw, "token")
		}
		return out
	}
	if list := d.Get("aks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AKSUserImpersonation{}
		}
		out := &sdm.AKSUserImpersonation{
			ID:                   d.Id(),
			CertificateAuthority: convertStringFromMap(raw, "certificate_authority"),
			ClientCertificate:    convertStringFromMap(raw, "client_certificate"),
			ClientKey:            convertStringFromMap(raw, "client_key"),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		return out
	}
	if list := d.Get("amazon_eks").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKS{}
		}
		out := &sdm.AmazonEKS{
			ID:                   d.Id(),
			AccessKey:            convertStringFromMap(raw, "access_key"),
			CertificateAuthority: convertStringFromMap(raw, "certificate_authority"),
			ClusterName:          convertStringFromMap(raw, "cluster_name"),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			Endpoint:             convertStringFromMap(raw, "endpoint"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Name:                 convertStringFromMap(raw, "name"),
			Region:               convertStringFromMap(raw, "region"),
			RoleArn:              convertStringFromMap(raw, "role_arn"),
			RoleExternalID:       convertStringFromMap(raw, "role_external_id"),
			SecretAccessKey:      convertStringFromMap(raw, "secret_access_key"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
		}
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("amazon_eks_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonEKSUserImpersonation{}
		}
		out := &sdm.AmazonEKSUserImpersonation{
			ID:                   d.Id(),
			AccessKey:            convertStringFromMap(raw, "access_key"),
			CertificateAuthority: convertStringFromMap(raw, "certificate_authority"),
			ClusterName:          convertStringFromMap(raw, "cluster_name"),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			Endpoint:             convertStringFromMap(raw, "endpoint"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Name:                 convertStringFromMap(raw, "name"),
			Region:               convertStringFromMap(raw, "region"),
			RoleArn:              convertStringFromMap(raw, "role_arn"),
			RoleExternalID:       convertStringFromMap(raw, "role_external_id"),
			SecretAccessKey:      convertStringFromMap(raw, "secret_access_key"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
		}
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("amazon_es").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonES{}
		}
		out := &sdm.AmazonES{
			ID:              d.Id(),
			AccessKey:       convertStringFromMap(raw, "access_key"),
			EgressFilter:    convertStringFromMap(raw, "egress_filter"),
			Endpoint:        convertStringFromMap(raw, "endpoint"),
			Name:            convertStringFromMap(raw, "name"),
			Region:          convertStringFromMap(raw, "region"),
			RoleArn:         convertStringFromMap(raw, "role_arn"),
			RoleExternalID:  convertStringFromMap(raw, "role_external_id"),
			SecretAccessKey: convertStringFromMap(raw, "secret_access_key"),
			SecretStoreID:   convertStringFromMap(raw, "secret_store_id"),
			Tags:            convertTagsFromMap(raw, "tags"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("amazonmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AmazonMQAMQP091{}
		}
		out := &sdm.AmazonMQAMQP091{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("athena").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Athena{}
		}
		out := &sdm.Athena{
			ID:              d.Id(),
			AccessKey:       convertStringFromMap(raw, "access_key"),
			EgressFilter:    convertStringFromMap(raw, "egress_filter"),
			Name:            convertStringFromMap(raw, "name"),
			Output:          convertStringFromMap(raw, "output"),
			Region:          convertStringFromMap(raw, "region"),
			RoleArn:         convertStringFromMap(raw, "role_arn"),
			RoleExternalID:  convertStringFromMap(raw, "role_external_id"),
			SecretAccessKey: convertStringFromMap(raw, "secret_access_key"),
			SecretStoreID:   convertStringFromMap(raw, "secret_store_id"),
			Tags:            convertTagsFromMap(raw, "tags"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("aurora_mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraMysql{}
		}
		out := &sdm.AuroraMysql{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("aurora_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AuroraPostgres{}
		}
		out := &sdm.AuroraPostgres{
			ID:               d.Id(),
			Database:         convertStringFromMap(raw, "database"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("aws").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AWS{}
		}
		out := &sdm.AWS{
			ID:                d.Id(),
			AccessKey:         convertStringFromMap(raw, "access_key"),
			EgressFilter:      convertStringFromMap(raw, "egress_filter"),
			HealthcheckRegion: convertStringFromMap(raw, "healthcheck_region"),
			Name:              convertStringFromMap(raw, "name"),
			RoleArn:           convertStringFromMap(raw, "role_arn"),
			RoleExternalID:    convertStringFromMap(raw, "role_external_id"),
			SecretAccessKey:   convertStringFromMap(raw, "secret_access_key"),
			SecretStoreID:     convertStringFromMap(raw, "secret_store_id"),
			Tags:              convertTagsFromMap(raw, "tags"),
		}
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("azure").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Azure{}
		}
		out := &sdm.Azure{
			ID:            d.Id(),
			AppID:         convertStringFromMap(raw, "app_id"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TenantID:      convertStringFromMap(raw, "tenant_id"),
		}
		if out.AppID == "" {
			out.AppID = fullSecretStorePath(raw, "app_id")
		}
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.TenantID == "" {
			out.TenantID = fullSecretStorePath(raw, "tenant_id")
		}
		return out
	}
	if list := d.Get("azure_certificate").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzureCertificate{}
		}
		out := &sdm.AzureCertificate{
			ID:                d.Id(),
			AppID:             convertStringFromMap(raw, "app_id"),
			ClientCertificate: convertStringFromMap(raw, "client_certificate"),
			EgressFilter:      convertStringFromMap(raw, "egress_filter"),
			Name:              convertStringFromMap(raw, "name"),
			SecretStoreID:     convertStringFromMap(raw, "secret_store_id"),
			Tags:              convertTagsFromMap(raw, "tags"),
			TenantID:          convertStringFromMap(raw, "tenant_id"),
		}
		if out.AppID == "" {
			out.AppID = fullSecretStorePath(raw, "app_id")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.TenantID == "" {
			out.TenantID = fullSecretStorePath(raw, "tenant_id")
		}
		return out
	}
	if list := d.Get("azure_postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.AzurePostgres{}
		}
		out := &sdm.AzurePostgres{
			ID:               d.Id(),
			Database:         convertStringFromMap(raw, "database"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("big_query").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.BigQuery{}
		}
		out := &sdm.BigQuery{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Endpoint:      convertStringFromMap(raw, "endpoint"),
			Name:          convertStringFromMap(raw, "name"),
			PrivateKey:    convertStringFromMap(raw, "private_key"),
			Project:       convertStringFromMap(raw, "project"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.PrivateKey == "" {
			out.PrivateKey = fullSecretStorePath(raw, "private_key")
		}
		return out
	}
	if list := d.Get("cassandra").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Cassandra{}
		}
		out := &sdm.Cassandra{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("citus").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Citus{}
		}
		out := &sdm.Citus{
			ID:               d.Id(),
			Database:         convertStringFromMap(raw, "database"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("clustrix").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Clustrix{}
		}
		out := &sdm.Clustrix{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("cockroach").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Cockroach{}
		}
		out := &sdm.Cockroach{
			ID:               d.Id(),
			Database:         convertStringFromMap(raw, "database"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("db_2_i").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DB2I{}
		}
		out := &sdm.DB2I{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("db_2_luw").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DB2LUW{}
		}
		out := &sdm.DB2LUW{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("document_db_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DocumentDBHost{}
		}
		out := &sdm.DocumentDBHost{
			ID:            d.Id(),
			AuthDatabase:  convertStringFromMap(raw, "auth_database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("document_db_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DocumentDBReplicaSet{}
		}
		out := &sdm.DocumentDBReplicaSet{
			ID:               d.Id(),
			AuthDatabase:     convertStringFromMap(raw, "auth_database"),
			ConnectToReplica: convertBoolFromMap(raw, "connect_to_replica"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			Password:         convertStringFromMap(raw, "password"),
			ReplicaSet:       convertStringFromMap(raw, "replica_set"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("druid").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Druid{}
		}
		out := &sdm.Druid{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("dynamo_db").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.DynamoDB{}
		}
		out := &sdm.DynamoDB{
			ID:              d.Id(),
			AccessKey:       convertStringFromMap(raw, "access_key"),
			EgressFilter:    convertStringFromMap(raw, "egress_filter"),
			Endpoint:        convertStringFromMap(raw, "endpoint"),
			Name:            convertStringFromMap(raw, "name"),
			Region:          convertStringFromMap(raw, "region"),
			RoleArn:         convertStringFromMap(raw, "role_arn"),
			RoleExternalID:  convertStringFromMap(raw, "role_external_id"),
			SecretAccessKey: convertStringFromMap(raw, "secret_access_key"),
			SecretStoreID:   convertStringFromMap(raw, "secret_store_id"),
			Tags:            convertTagsFromMap(raw, "tags"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("elastic").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Elastic{}
		}
		out := &sdm.Elastic{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("elasticache_redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.ElasticacheRedis{}
		}
		out := &sdm.ElasticacheRedis{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		return out
	}
	if list := d.Get("gcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GCP{}
		}
		out := &sdm.GCP{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Keyfile:       convertStringFromMap(raw, "keyfile"),
			Name:          convertStringFromMap(raw, "name"),
			Scopes:        convertStringFromMap(raw, "scopes"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
		}
		if out.Keyfile == "" {
			out.Keyfile = fullSecretStorePath(raw, "keyfile")
		}
		return out
	}
	if list := d.Get("google_gke").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GoogleGKE{}
		}
		out := &sdm.GoogleGKE{
			ID:                   d.Id(),
			CertificateAuthority: convertStringFromMap(raw, "certificate_authority"),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			Endpoint:             convertStringFromMap(raw, "endpoint"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Name:                 convertStringFromMap(raw, "name"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			ServiceAccountKey:    convertStringFromMap(raw, "service_account_key"),
			Tags:                 convertTagsFromMap(raw, "tags"),
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ServiceAccountKey == "" {
			out.ServiceAccountKey = fullSecretStorePath(raw, "service_account_key")
		}
		return out
	}
	if list := d.Get("google_gke_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.GoogleGKEUserImpersonation{}
		}
		out := &sdm.GoogleGKEUserImpersonation{
			ID:                   d.Id(),
			CertificateAuthority: convertStringFromMap(raw, "certificate_authority"),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			Endpoint:             convertStringFromMap(raw, "endpoint"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Name:                 convertStringFromMap(raw, "name"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			ServiceAccountKey:    convertStringFromMap(raw, "service_account_key"),
			Tags:                 convertTagsFromMap(raw, "tags"),
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ServiceAccountKey == "" {
			out.ServiceAccountKey = fullSecretStorePath(raw, "service_account_key")
		}
		return out
	}
	if list := d.Get("greenplum").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Greenplum{}
		}
		out := &sdm.Greenplum{
			ID:               d.Id(),
			Database:         convertStringFromMap(raw, "database"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("http_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPAuth{}
		}
		out := &sdm.HTTPAuth{
			ID:               d.Id(),
			AuthHeader:       convertStringFromMap(raw, "auth_header"),
			DefaultPath:      convertStringFromMap(raw, "default_path"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			HeadersBlacklist: convertStringFromMap(raw, "headers_blacklist"),
			HealthcheckPath:  convertStringFromMap(raw, "healthcheck_path"),
			Name:             convertStringFromMap(raw, "name"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Subdomain:        convertStringFromMap(raw, "subdomain"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Url:              convertStringFromMap(raw, "url"),
		}
		if out.AuthHeader == "" {
			out.AuthHeader = fullSecretStorePath(raw, "auth_header")
		}
		return out
	}
	if list := d.Get("http_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPBasicAuth{}
		}
		out := &sdm.HTTPBasicAuth{
			ID:               d.Id(),
			DefaultPath:      convertStringFromMap(raw, "default_path"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			HeadersBlacklist: convertStringFromMap(raw, "headers_blacklist"),
			HealthcheckPath:  convertStringFromMap(raw, "healthcheck_path"),
			Name:             convertStringFromMap(raw, "name"),
			Password:         convertStringFromMap(raw, "password"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Subdomain:        convertStringFromMap(raw, "subdomain"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Url:              convertStringFromMap(raw, "url"),
			Username:         convertStringFromMap(raw, "username"),
		}
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("http_no_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.HTTPNoAuth{}
		}
		out := &sdm.HTTPNoAuth{
			ID:               d.Id(),
			DefaultPath:      convertStringFromMap(raw, "default_path"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			HeadersBlacklist: convertStringFromMap(raw, "headers_blacklist"),
			HealthcheckPath:  convertStringFromMap(raw, "healthcheck_path"),
			Name:             convertStringFromMap(raw, "name"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Subdomain:        convertStringFromMap(raw, "subdomain"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Url:              convertStringFromMap(raw, "url"),
		}
		return out
	}
	if list := d.Get("kubernetes").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Kubernetes{}
		}
		out := &sdm.Kubernetes{
			ID:                   d.Id(),
			CertificateAuthority: convertStringFromMap(raw, "certificate_authority"),
			ClientCertificate:    convertStringFromMap(raw, "client_certificate"),
			ClientKey:            convertStringFromMap(raw, "client_key"),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		return out
	}
	if list := d.Get("kubernetes_basic_auth").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesBasicAuth{}
		}
		out := &sdm.KubernetesBasicAuth{
			ID:                   d.Id(),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Password:             convertStringFromMap(raw, "password"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Username:             convertStringFromMap(raw, "username"),
		}
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("kubernetes_service_account").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesServiceAccount{}
		}
		out := &sdm.KubernetesServiceAccount{
			ID:                   d.Id(),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Token:                convertStringFromMap(raw, "token"),
		}
		if out.Token == "" {
			out.Token = fullSecretStorePath(raw, "token")
		}
		return out
	}
	if list := d.Get("kubernetes_service_account_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesServiceAccountUserImpersonation{}
		}
		out := &sdm.KubernetesServiceAccountUserImpersonation{
			ID:                   d.Id(),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
			Token:                convertStringFromMap(raw, "token"),
		}
		if out.Token == "" {
			out.Token = fullSecretStorePath(raw, "token")
		}
		return out
	}
	if list := d.Get("kubernetes_user_impersonation").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.KubernetesUserImpersonation{}
		}
		out := &sdm.KubernetesUserImpersonation{
			ID:                   d.Id(),
			CertificateAuthority: convertStringFromMap(raw, "certificate_authority"),
			ClientCertificate:    convertStringFromMap(raw, "client_certificate"),
			ClientKey:            convertStringFromMap(raw, "client_key"),
			EgressFilter:         convertStringFromMap(raw, "egress_filter"),
			HealthcheckNamespace: convertStringFromMap(raw, "healthcheck_namespace"),
			Hostname:             convertStringFromMap(raw, "hostname"),
			Name:                 convertStringFromMap(raw, "name"),
			Port:                 convertInt32FromMap(raw, "port"),
			SecretStoreID:        convertStringFromMap(raw, "secret_store_id"),
			Tags:                 convertTagsFromMap(raw, "tags"),
		}
		if out.CertificateAuthority == "" {
			out.CertificateAuthority = fullSecretStorePath(raw, "certificate_authority")
		}
		if out.ClientCertificate == "" {
			out.ClientCertificate = fullSecretStorePath(raw, "client_certificate")
		}
		if out.ClientKey == "" {
			out.ClientKey = fullSecretStorePath(raw, "client_key")
		}
		return out
	}
	if list := d.Get("maria").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Maria{}
		}
		out := &sdm.Maria{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("memcached").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Memcached{}
		}
		out := &sdm.Memcached{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("memsql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Memsql{}
		}
		out := &sdm.Memsql{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoHost{}
		}
		out := &sdm.MongoHost{
			ID:            d.Id(),
			AuthDatabase:  convertStringFromMap(raw, "auth_database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_legacy_host").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoLegacyHost{}
		}
		out := &sdm.MongoLegacyHost{
			ID:            d.Id(),
			AuthDatabase:  convertStringFromMap(raw, "auth_database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			ReplicaSet:    convertStringFromMap(raw, "replica_set"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_legacy_replicaset").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoLegacyReplicaset{}
		}
		out := &sdm.MongoLegacyReplicaset{
			ID:               d.Id(),
			AuthDatabase:     convertStringFromMap(raw, "auth_database"),
			ConnectToReplica: convertBoolFromMap(raw, "connect_to_replica"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			ReplicaSet:       convertStringFromMap(raw, "replica_set"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			TlsRequired:      convertBoolFromMap(raw, "tls_required"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_replica_set").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoReplicaSet{}
		}
		out := &sdm.MongoReplicaSet{
			ID:               d.Id(),
			AuthDatabase:     convertStringFromMap(raw, "auth_database"),
			ConnectToReplica: convertBoolFromMap(raw, "connect_to_replica"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			ReplicaSet:       convertStringFromMap(raw, "replica_set"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			TlsRequired:      convertBoolFromMap(raw, "tls_required"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mongo_sharded_cluster").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.MongoShardedCluster{}
		}
		out := &sdm.MongoShardedCluster{
			ID:            d.Id(),
			AuthDatabase:  convertStringFromMap(raw, "auth_database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("mysql").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Mysql{}
		}
		out := &sdm.Mysql{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("neptune").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Neptune{}
		}
		out := &sdm.Neptune{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Endpoint:      convertStringFromMap(raw, "endpoint"),
			Name:          convertStringFromMap(raw, "name"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("neptune_iam").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.NeptuneIAM{}
		}
		out := &sdm.NeptuneIAM{
			ID:              d.Id(),
			AccessKey:       convertStringFromMap(raw, "access_key"),
			EgressFilter:    convertStringFromMap(raw, "egress_filter"),
			Endpoint:        convertStringFromMap(raw, "endpoint"),
			Name:            convertStringFromMap(raw, "name"),
			Port:            convertInt32FromMap(raw, "port"),
			Region:          convertStringFromMap(raw, "region"),
			RoleArn:         convertStringFromMap(raw, "role_arn"),
			RoleExternalID:  convertStringFromMap(raw, "role_external_id"),
			SecretAccessKey: convertStringFromMap(raw, "secret_access_key"),
			SecretStoreID:   convertStringFromMap(raw, "secret_store_id"),
			Tags:            convertTagsFromMap(raw, "tags"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.AccessKey == "" {
			out.AccessKey = fullSecretStorePath(raw, "access_key")
		}
		if out.RoleArn == "" {
			out.RoleArn = fullSecretStorePath(raw, "role_arn")
		}
		if out.RoleExternalID == "" {
			out.RoleExternalID = fullSecretStorePath(raw, "role_external_id")
		}
		if out.SecretAccessKey == "" {
			out.SecretAccessKey = fullSecretStorePath(raw, "secret_access_key")
		}
		return out
	}
	if list := d.Get("oracle").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Oracle{}
		}
		out := &sdm.Oracle{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("postgres").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Postgres{}
		}
		out := &sdm.Postgres{
			ID:               d.Id(),
			Database:         convertStringFromMap(raw, "database"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("presto").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Presto{}
		}
		out := &sdm.Presto{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		return out
	}
	if list := d.Get("rabbitmq_amqp_091").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RabbitMQAMQP091{}
		}
		out := &sdm.RabbitMQAMQP091{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			TlsRequired:   convertBoolFromMap(raw, "tls_required"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("raw_tcp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RawTCP{}
		}
		out := &sdm.RawTCP{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		return out
	}
	if list := d.Get("rdp").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.RDP{}
		}
		out := &sdm.RDP{
			ID:                      d.Id(),
			DowngradeNlaConnections: convertBoolFromMap(raw, "downgrade_nla_connections"),
			EgressFilter:            convertStringFromMap(raw, "egress_filter"),
			Hostname:                convertStringFromMap(raw, "hostname"),
			Name:                    convertStringFromMap(raw, "name"),
			Password:                convertStringFromMap(raw, "password"),
			Port:                    convertInt32FromMap(raw, "port"),
			SecretStoreID:           convertStringFromMap(raw, "secret_store_id"),
			Tags:                    convertTagsFromMap(raw, "tags"),
			Username:                convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("redis").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Redis{}
		}
		out := &sdm.Redis{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		return out
	}
	if list := d.Get("redshift").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Redshift{}
		}
		out := &sdm.Redshift{
			ID:               d.Id(),
			Database:         convertStringFromMap(raw, "database"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("single_store").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SingleStore{}
		}
		out := &sdm.SingleStore{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("snowflake").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Snowflake{}
		}
		out := &sdm.Snowflake{
			ID:            d.Id(),
			Database:      convertStringFromMap(raw, "database"),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Schema:        convertStringFromMap(raw, "schema"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("sql_server").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SQLServer{}
		}
		out := &sdm.SQLServer{
			ID:               d.Id(),
			Database:         convertStringFromMap(raw, "database"),
			EgressFilter:     convertStringFromMap(raw, "egress_filter"),
			Hostname:         convertStringFromMap(raw, "hostname"),
			Name:             convertStringFromMap(raw, "name"),
			OverrideDatabase: convertBoolFromMap(raw, "override_database"),
			Password:         convertStringFromMap(raw, "password"),
			Port:             convertInt32FromMap(raw, "port"),
			Schema:           convertStringFromMap(raw, "schema"),
			SecretStoreID:    convertStringFromMap(raw, "secret_store_id"),
			Tags:             convertTagsFromMap(raw, "tags"),
			Username:         convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("ssh").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSH{}
		}
		out := &sdm.SSH{
			ID:                          d.Id(),
			AllowDeprecatedKeyExchanges: convertBoolFromMap(raw, "allow_deprecated_key_exchanges"),
			EgressFilter:                convertStringFromMap(raw, "egress_filter"),
			Hostname:                    convertStringFromMap(raw, "hostname"),
			Name:                        convertStringFromMap(raw, "name"),
			Port:                        convertInt32FromMap(raw, "port"),
			PortForwarding:              convertBoolFromMap(raw, "port_forwarding"),
			SecretStoreID:               convertStringFromMap(raw, "secret_store_id"),
			Tags:                        convertTagsFromMap(raw, "tags"),
			Username:                    convertStringFromMap(raw, "username"),
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("ssh_cert").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSHCert{}
		}
		out := &sdm.SSHCert{
			ID:                          d.Id(),
			AllowDeprecatedKeyExchanges: convertBoolFromMap(raw, "allow_deprecated_key_exchanges"),
			EgressFilter:                convertStringFromMap(raw, "egress_filter"),
			Hostname:                    convertStringFromMap(raw, "hostname"),
			Name:                        convertStringFromMap(raw, "name"),
			Port:                        convertInt32FromMap(raw, "port"),
			PortForwarding:              convertBoolFromMap(raw, "port_forwarding"),
			SecretStoreID:               convertStringFromMap(raw, "secret_store_id"),
			Tags:                        convertTagsFromMap(raw, "tags"),
			Username:                    convertStringFromMap(raw, "username"),
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("ssh_customer_key").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SSHCustomerKey{}
		}
		out := &sdm.SSHCustomerKey{
			ID:                          d.Id(),
			AllowDeprecatedKeyExchanges: convertBoolFromMap(raw, "allow_deprecated_key_exchanges"),
			EgressFilter:                convertStringFromMap(raw, "egress_filter"),
			Hostname:                    convertStringFromMap(raw, "hostname"),
			Name:                        convertStringFromMap(raw, "name"),
			Port:                        convertInt32FromMap(raw, "port"),
			PortForwarding:              convertBoolFromMap(raw, "port_forwarding"),
			PrivateKey:                  convertStringFromMap(raw, "private_key"),
			SecretStoreID:               convertStringFromMap(raw, "secret_store_id"),
			Tags:                        convertTagsFromMap(raw, "tags"),
			Username:                    convertStringFromMap(raw, "username"),
		}
		if out.PrivateKey == "" {
			out.PrivateKey = fullSecretStorePath(raw, "private_key")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("sybase").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Sybase{}
		}
		out := &sdm.Sybase{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("sybase_iq").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.SybaseIQ{}
		}
		out := &sdm.SybaseIQ{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	if list := d.Get("teradata").([]interface{}); len(list) > 0 {
		raw, ok := list[0].(map[string]interface{})
		if !ok {
			return &sdm.Teradata{}
		}
		out := &sdm.Teradata{
			ID:            d.Id(),
			EgressFilter:  convertStringFromMap(raw, "egress_filter"),
			Hostname:      convertStringFromMap(raw, "hostname"),
			Name:          convertStringFromMap(raw, "name"),
			Password:      convertStringFromMap(raw, "password"),
			Port:          convertInt32FromMap(raw, "port"),
			SecretStoreID: convertStringFromMap(raw, "secret_store_id"),
			Tags:          convertTagsFromMap(raw, "tags"),
			Username:      convertStringFromMap(raw, "username"),
		}
		override, ok := raw["port_override"].(int)
		if !ok || override == 0 {
			override = -1
		}
		out.PortOverride = int32(override)
		if out.Password == "" {
			out.Password = fullSecretStorePath(raw, "password")
		}
		if out.Username == "" {
			out.Username = fullSecretStorePath(raw, "username")
		}
		return out
	}
	return nil
}

func resourceResourceCreate(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	localVersion := convertResourceFromResourceData(d)
	seValues, err := secretStoreValuesForResource(d)
	if err != nil {
		return fmt.Errorf("cannot create Resource: %w", err)
	}

	resp, err := cc.Resources().Create(ctx, localVersion)
	if err != nil {
		return fmt.Errorf("cannot create Resource: %w", err)
	}
	d.SetId(resp.Resource.GetID())
	switch v := resp.Resource.(type) {
	case *sdm.AKS:
		localV, _ := localVersion.(*sdm.AKS)
		_ = localV
		d.Set("aks", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AKSBasicAuth:
		localV, _ := localVersion.(*sdm.AKSBasicAuth)
		_ = localV
		d.Set("aks_basic_auth", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"healthcheck_namespace":      (v.HealthcheckNamespace),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AKSServiceAccount:
		localV, _ := localVersion.(*sdm.AKSServiceAccount)
		_ = localV
		d.Set("aks_service_account", []map[string]interface{}{
			{
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"secret_store_id":         (v.SecretStoreID),
				"tags":                    convertTagsToMap(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.AKSServiceAccountUserImpersonation:
		localV, _ := localVersion.(*sdm.AKSServiceAccountUserImpersonation)
		_ = localV
		d.Set("aks_service_account_user_impersonation", []map[string]interface{}{
			{
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"secret_store_id":         (v.SecretStoreID),
				"tags":                    convertTagsToMap(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.AKSUserImpersonation:
		localV, _ := localVersion.(*sdm.AKSUserImpersonation)
		_ = localV
		d.Set("aks_user_impersonation", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AmazonEKS:
		localV, _ := localVersion.(*sdm.AmazonEKS)
		_ = localV
		d.Set("amazon_eks", []map[string]interface{}{
			{
				"access_key":                              seValues["access_key"],
				"secret_store_access_key_path":            seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":             seValues["secret_store_access_key_key"],
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"region":                                  (v.Region),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_access_key":                       seValues["secret_access_key"],
				"secret_store_secret_access_key_path":     seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":      seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AmazonEKSUserImpersonation:
		localV, _ := localVersion.(*sdm.AmazonEKSUserImpersonation)
		_ = localV
		d.Set("amazon_eks_user_impersonation", []map[string]interface{}{
			{
				"access_key":                              seValues["access_key"],
				"secret_store_access_key_path":            seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":             seValues["secret_store_access_key_key"],
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"region":                                  (v.Region),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_access_key":                       seValues["secret_access_key"],
				"secret_store_secret_access_key_path":     seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":      seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AmazonES:
		localV, _ := localVersion.(*sdm.AmazonES)
		_ = localV
		d.Set("amazon_es", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AmazonMQAMQP091:
		localV, _ := localVersion.(*sdm.AmazonMQAMQP091)
		_ = localV
		d.Set("amazonmq_amqp_091", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Athena:
		localV, _ := localVersion.(*sdm.Athena)
		_ = localV
		d.Set("athena", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"name":                                (v.Name),
				"output":                              (v.Output),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AuroraMysql:
		localV, _ := localVersion.(*sdm.AuroraMysql)
		_ = localV
		d.Set("aurora_mysql", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AuroraPostgres:
		localV, _ := localVersion.(*sdm.AuroraPostgres)
		_ = localV
		d.Set("aurora_postgres", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AWS:
		localV, _ := localVersion.(*sdm.AWS)
		_ = localV
		d.Set("aws", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_region":                  (v.HealthcheckRegion),
				"name":                                (v.Name),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Azure:
		localV, _ := localVersion.(*sdm.Azure)
		_ = localV
		d.Set("azure", []map[string]interface{}{
			{
				"app_id":                      seValues["app_id"],
				"secret_store_app_id_path":    seValues["secret_store_app_id_path"],
				"secret_store_app_id_key":     seValues["secret_store_app_id_key"],
				"egress_filter":               (v.EgressFilter),
				"name":                        (v.Name),
				"password":                    seValues["password"],
				"secret_store_password_path":  seValues["secret_store_password_path"],
				"secret_store_password_key":   seValues["secret_store_password_key"],
				"secret_store_id":             (v.SecretStoreID),
				"tags":                        convertTagsToMap(v.Tags),
				"tenant_id":                   seValues["tenant_id"],
				"secret_store_tenant_id_path": seValues["secret_store_tenant_id_path"],
				"secret_store_tenant_id_key":  seValues["secret_store_tenant_id_key"],
			},
		})
	case *sdm.AzureCertificate:
		localV, _ := localVersion.(*sdm.AzureCertificate)
		_ = localV
		d.Set("azure_certificate", []map[string]interface{}{
			{
				"app_id":                               seValues["app_id"],
				"secret_store_app_id_path":             seValues["secret_store_app_id_path"],
				"secret_store_app_id_key":              seValues["secret_store_app_id_key"],
				"client_certificate":                   seValues["client_certificate"],
				"secret_store_client_certificate_path": seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":  seValues["secret_store_client_certificate_key"],
				"egress_filter":                        (v.EgressFilter),
				"name":                                 (v.Name),
				"secret_store_id":                      (v.SecretStoreID),
				"tags":                                 convertTagsToMap(v.Tags),
				"tenant_id":                            seValues["tenant_id"],
				"secret_store_tenant_id_path":          seValues["secret_store_tenant_id_path"],
				"secret_store_tenant_id_key":           seValues["secret_store_tenant_id_key"],
			},
		})
	case *sdm.AzurePostgres:
		localV, _ := localVersion.(*sdm.AzurePostgres)
		_ = localV
		d.Set("azure_postgres", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.BigQuery:
		localV, _ := localVersion.(*sdm.BigQuery)
		_ = localV
		d.Set("big_query", []map[string]interface{}{
			{
				"egress_filter":                 (v.EgressFilter),
				"endpoint":                      (v.Endpoint),
				"name":                          (v.Name),
				"port_override":                 (v.PortOverride),
				"private_key":                   seValues["private_key"],
				"secret_store_private_key_path": seValues["secret_store_private_key_path"],
				"secret_store_private_key_key":  seValues["secret_store_private_key_key"],
				"project":                       (v.Project),
				"secret_store_id":               (v.SecretStoreID),
				"tags":                          convertTagsToMap(v.Tags),
				"username":                      (v.Username),
			},
		})
	case *sdm.Cassandra:
		localV, _ := localVersion.(*sdm.Cassandra)
		_ = localV
		d.Set("cassandra", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Citus:
		localV, _ := localVersion.(*sdm.Citus)
		_ = localV
		d.Set("citus", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Clustrix:
		localV, _ := localVersion.(*sdm.Clustrix)
		_ = localV
		d.Set("clustrix", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Cockroach:
		localV, _ := localVersion.(*sdm.Cockroach)
		_ = localV
		d.Set("cockroach", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DB2I:
		localV, _ := localVersion.(*sdm.DB2I)
		_ = localV
		d.Set("db_2_i", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DB2LUW:
		localV, _ := localVersion.(*sdm.DB2LUW)
		_ = localV
		d.Set("db_2_luw", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DocumentDBHost:
		localV, _ := localVersion.(*sdm.DocumentDBHost)
		_ = localV
		d.Set("document_db_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DocumentDBReplicaSet:
		localV, _ := localVersion.(*sdm.DocumentDBReplicaSet)
		_ = localV
		d.Set("document_db_replica_set", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Druid:
		localV, _ := localVersion.(*sdm.Druid)
		_ = localV
		d.Set("druid", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DynamoDB:
		localV, _ := localVersion.(*sdm.DynamoDB)
		_ = localV
		d.Set("dynamo_db", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Elastic:
		localV, _ := localVersion.(*sdm.Elastic)
		_ = localV
		d.Set("elastic", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.ElasticacheRedis:
		localV, _ := localVersion.(*sdm.ElasticacheRedis)
		_ = localV
		d.Set("elasticache_redis", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
			},
		})
	case *sdm.GCP:
		localV, _ := localVersion.(*sdm.GCP)
		_ = localV
		d.Set("gcp", []map[string]interface{}{
			{
				"egress_filter":             (v.EgressFilter),
				"keyfile":                   seValues["keyfile"],
				"secret_store_keyfile_path": seValues["secret_store_keyfile_path"],
				"secret_store_keyfile_key":  seValues["secret_store_keyfile_key"],
				"name":                      (v.Name),
				"scopes":                    (v.Scopes),
				"secret_store_id":           (v.SecretStoreID),
				"tags":                      convertTagsToMap(v.Tags),
			},
		})
	case *sdm.GoogleGKE:
		localV, _ := localVersion.(*sdm.GoogleGKE)
		_ = localV
		d.Set("google_gke", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"secret_store_id":                         (v.SecretStoreID),
				"service_account_key":                     seValues["service_account_key"],
				"secret_store_service_account_key_path":   seValues["secret_store_service_account_key_path"],
				"secret_store_service_account_key_key":    seValues["secret_store_service_account_key_key"],
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.GoogleGKEUserImpersonation:
		localV, _ := localVersion.(*sdm.GoogleGKEUserImpersonation)
		_ = localV
		d.Set("google_gke_user_impersonation", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"secret_store_id":                         (v.SecretStoreID),
				"service_account_key":                     seValues["service_account_key"],
				"secret_store_service_account_key_path":   seValues["secret_store_service_account_key_path"],
				"secret_store_service_account_key_key":    seValues["secret_store_service_account_key_key"],
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Greenplum:
		localV, _ := localVersion.(*sdm.Greenplum)
		_ = localV
		d.Set("greenplum", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.HTTPAuth:
		localV, _ := localVersion.(*sdm.HTTPAuth)
		_ = localV
		d.Set("http_auth", []map[string]interface{}{
			{
				"auth_header":                   seValues["auth_header"],
				"secret_store_auth_header_path": seValues["secret_store_auth_header_path"],
				"secret_store_auth_header_key":  seValues["secret_store_auth_header_key"],
				"default_path":                  (v.DefaultPath),
				"egress_filter":                 (v.EgressFilter),
				"headers_blacklist":             (v.HeadersBlacklist),
				"healthcheck_path":              (v.HealthcheckPath),
				"name":                          (v.Name),
				"secret_store_id":               (v.SecretStoreID),
				"subdomain":                     (v.Subdomain),
				"tags":                          convertTagsToMap(v.Tags),
				"url":                           (v.Url),
			},
		})
	case *sdm.HTTPBasicAuth:
		localV, _ := localVersion.(*sdm.HTTPBasicAuth)
		_ = localV
		d.Set("http_basic_auth", []map[string]interface{}{
			{
				"default_path":               (v.DefaultPath),
				"egress_filter":              (v.EgressFilter),
				"headers_blacklist":          (v.HeadersBlacklist),
				"healthcheck_path":           (v.HealthcheckPath),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToMap(v.Tags),
				"url":                        (v.Url),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.HTTPNoAuth:
		localV, _ := localVersion.(*sdm.HTTPNoAuth)
		_ = localV
		d.Set("http_no_auth", []map[string]interface{}{
			{
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"name":              (v.Name),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToMap(v.Tags),
				"url":               (v.Url),
			},
		})
	case *sdm.Kubernetes:
		localV, _ := localVersion.(*sdm.Kubernetes)
		_ = localV
		d.Set("kubernetes", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.KubernetesBasicAuth:
		localV, _ := localVersion.(*sdm.KubernetesBasicAuth)
		_ = localV
		d.Set("kubernetes_basic_auth", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"healthcheck_namespace":      (v.HealthcheckNamespace),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.KubernetesServiceAccount:
		localV, _ := localVersion.(*sdm.KubernetesServiceAccount)
		_ = localV
		d.Set("kubernetes_service_account", []map[string]interface{}{
			{
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"secret_store_id":         (v.SecretStoreID),
				"tags":                    convertTagsToMap(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.KubernetesServiceAccountUserImpersonation:
		localV, _ := localVersion.(*sdm.KubernetesServiceAccountUserImpersonation)
		_ = localV
		d.Set("kubernetes_service_account_user_impersonation", []map[string]interface{}{
			{
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"secret_store_id":         (v.SecretStoreID),
				"tags":                    convertTagsToMap(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.KubernetesUserImpersonation:
		localV, _ := localVersion.(*sdm.KubernetesUserImpersonation)
		_ = localV
		d.Set("kubernetes_user_impersonation", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Maria:
		localV, _ := localVersion.(*sdm.Maria)
		_ = localV
		d.Set("maria", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Memcached:
		localV, _ := localVersion.(*sdm.Memcached)
		_ = localV
		d.Set("memcached", []map[string]interface{}{
			{
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"tags":            convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Memsql:
		localV, _ := localVersion.(*sdm.Memsql)
		_ = localV
		d.Set("memsql", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoHost:
		localV, _ := localVersion.(*sdm.MongoHost)
		_ = localV
		d.Set("mongo_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoLegacyHost:
		localV, _ := localVersion.(*sdm.MongoLegacyHost)
		_ = localV
		d.Set("mongo_legacy_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoLegacyReplicaset:
		localV, _ := localVersion.(*sdm.MongoLegacyReplicaset)
		_ = localV
		d.Set("mongo_legacy_replicaset", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoReplicaSet:
		localV, _ := localVersion.(*sdm.MongoReplicaSet)
		_ = localV
		d.Set("mongo_replica_set", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoShardedCluster:
		localV, _ := localVersion.(*sdm.MongoShardedCluster)
		_ = localV
		d.Set("mongo_sharded_cluster", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Mysql:
		localV, _ := localVersion.(*sdm.Mysql)
		_ = localV
		d.Set("mysql", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Neptune:
		localV, _ := localVersion.(*sdm.Neptune)
		_ = localV
		d.Set("neptune", []map[string]interface{}{
			{
				"egress_filter":   (v.EgressFilter),
				"endpoint":        (v.Endpoint),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"tags":            convertTagsToMap(v.Tags),
			},
		})
	case *sdm.NeptuneIAM:
		localV, _ := localVersion.(*sdm.NeptuneIAM)
		_ = localV
		d.Set("neptune_iam", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Oracle:
		localV, _ := localVersion.(*sdm.Oracle)
		_ = localV
		d.Set("oracle", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Postgres:
		localV, _ := localVersion.(*sdm.Postgres)
		_ = localV
		d.Set("postgres", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Presto:
		localV, _ := localVersion.(*sdm.Presto)
		_ = localV
		d.Set("presto", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   (v.Username),
			},
		})
	case *sdm.RabbitMQAMQP091:
		localV, _ := localVersion.(*sdm.RabbitMQAMQP091)
		_ = localV
		d.Set("rabbitmq_amqp_091", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.RawTCP:
		localV, _ := localVersion.(*sdm.RawTCP)
		_ = localV
		d.Set("raw_tcp", []map[string]interface{}{
			{
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"tags":            convertTagsToMap(v.Tags),
			},
		})
	case *sdm.RDP:
		localV, _ := localVersion.(*sdm.RDP)
		_ = localV
		d.Set("rdp", []map[string]interface{}{
			{
				"downgrade_nla_connections":  (v.DowngradeNlaConnections),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Redis:
		localV, _ := localVersion.(*sdm.Redis)
		_ = localV
		d.Set("redis", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Redshift:
		localV, _ := localVersion.(*sdm.Redshift)
		_ = localV
		d.Set("redshift", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SingleStore:
		localV, _ := localVersion.(*sdm.SingleStore)
		_ = localV
		d.Set("single_store", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Snowflake:
		localV, _ := localVersion.(*sdm.Snowflake)
		_ = localV
		d.Set("snowflake", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"schema":                     (v.Schema),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SQLServer:
		localV, _ := localVersion.(*sdm.SQLServer)
		_ = localV
		d.Set("sql_server", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"schema":                     (v.Schema),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSH:
		localV, _ := localVersion.(*sdm.SSH)
		_ = localV
		d.Set("ssh", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"public_key":                     (v.PublicKey),
				"secret_store_id":                (v.SecretStoreID),
				"tags":                           convertTagsToMap(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSHCert:
		localV, _ := localVersion.(*sdm.SSHCert)
		_ = localV
		d.Set("ssh_cert", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"secret_store_id":                (v.SecretStoreID),
				"tags":                           convertTagsToMap(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSHCustomerKey:
		localV, _ := localVersion.(*sdm.SSHCustomerKey)
		_ = localV
		d.Set("ssh_customer_key", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"private_key":                    seValues["private_key"],
				"secret_store_private_key_path":  seValues["secret_store_private_key_path"],
				"secret_store_private_key_key":   seValues["secret_store_private_key_key"],
				"secret_store_id":                (v.SecretStoreID),
				"tags":                           convertTagsToMap(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.Sybase:
		localV, _ := localVersion.(*sdm.Sybase)
		_ = localV
		d.Set("sybase", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SybaseIQ:
		localV, _ := localVersion.(*sdm.SybaseIQ)
		_ = localV
		d.Set("sybase_iq", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Teradata:
		localV, _ := localVersion.(*sdm.Teradata)
		_ = localV
		d.Set("teradata", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	}
	return nil
}

func resourceResourceRead(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	localVersion := convertResourceFromResourceData(d)
	_ = localVersion
	seValues, err := secretStoreValuesForResource(d)
	if err != nil {
		return fmt.Errorf("cannot read Resource %s: %w", d.Id(), err)
	}

	resp, err := cc.Resources().Get(ctx, d.Id())
	var errNotFound *sdm.NotFoundError
	if err != nil && errors.As(err, &errNotFound) {
		d.SetId("")
		return nil
	} else if err != nil {
		return fmt.Errorf("cannot read Resource %s: %w", d.Id(), err)
	}
	switch v := resp.Resource.(type) {
	case *sdm.AKS:
		localV, ok := localVersion.(*sdm.AKS)
		if !ok {
			localV = &sdm.AKS{}
		}
		_ = localV
		d.Set("aks", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AKSBasicAuth:
		localV, ok := localVersion.(*sdm.AKSBasicAuth)
		if !ok {
			localV = &sdm.AKSBasicAuth{}
		}
		_ = localV
		d.Set("aks_basic_auth", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"healthcheck_namespace":      (v.HealthcheckNamespace),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AKSServiceAccount:
		localV, ok := localVersion.(*sdm.AKSServiceAccount)
		if !ok {
			localV = &sdm.AKSServiceAccount{}
		}
		_ = localV
		d.Set("aks_service_account", []map[string]interface{}{
			{
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"secret_store_id":         (v.SecretStoreID),
				"tags":                    convertTagsToMap(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.AKSServiceAccountUserImpersonation:
		localV, ok := localVersion.(*sdm.AKSServiceAccountUserImpersonation)
		if !ok {
			localV = &sdm.AKSServiceAccountUserImpersonation{}
		}
		_ = localV
		d.Set("aks_service_account_user_impersonation", []map[string]interface{}{
			{
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"secret_store_id":         (v.SecretStoreID),
				"tags":                    convertTagsToMap(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.AKSUserImpersonation:
		localV, ok := localVersion.(*sdm.AKSUserImpersonation)
		if !ok {
			localV = &sdm.AKSUserImpersonation{}
		}
		_ = localV
		d.Set("aks_user_impersonation", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AmazonEKS:
		localV, ok := localVersion.(*sdm.AmazonEKS)
		if !ok {
			localV = &sdm.AmazonEKS{}
		}
		_ = localV
		d.Set("amazon_eks", []map[string]interface{}{
			{
				"access_key":                              seValues["access_key"],
				"secret_store_access_key_path":            seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":             seValues["secret_store_access_key_key"],
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"region":                                  (v.Region),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_access_key":                       seValues["secret_access_key"],
				"secret_store_secret_access_key_path":     seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":      seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AmazonEKSUserImpersonation:
		localV, ok := localVersion.(*sdm.AmazonEKSUserImpersonation)
		if !ok {
			localV = &sdm.AmazonEKSUserImpersonation{}
		}
		_ = localV
		d.Set("amazon_eks_user_impersonation", []map[string]interface{}{
			{
				"access_key":                              seValues["access_key"],
				"secret_store_access_key_path":            seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":             seValues["secret_store_access_key_key"],
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"cluster_name":                            (v.ClusterName),
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"region":                                  (v.Region),
				"role_arn":                                seValues["role_arn"],
				"secret_store_role_arn_path":              seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":               seValues["secret_store_role_arn_key"],
				"role_external_id":                        seValues["role_external_id"],
				"secret_store_role_external_id_path":      seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":       seValues["secret_store_role_external_id_key"],
				"secret_access_key":                       seValues["secret_access_key"],
				"secret_store_secret_access_key_path":     seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":      seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AmazonES:
		localV, ok := localVersion.(*sdm.AmazonES)
		if !ok {
			localV = &sdm.AmazonES{}
		}
		_ = localV
		d.Set("amazon_es", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AmazonMQAMQP091:
		localV, ok := localVersion.(*sdm.AmazonMQAMQP091)
		if !ok {
			localV = &sdm.AmazonMQAMQP091{}
		}
		_ = localV
		d.Set("amazonmq_amqp_091", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Athena:
		localV, ok := localVersion.(*sdm.Athena)
		if !ok {
			localV = &sdm.Athena{}
		}
		_ = localV
		d.Set("athena", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"name":                                (v.Name),
				"output":                              (v.Output),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.AuroraMysql:
		localV, ok := localVersion.(*sdm.AuroraMysql)
		if !ok {
			localV = &sdm.AuroraMysql{}
		}
		_ = localV
		d.Set("aurora_mysql", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AuroraPostgres:
		localV, ok := localVersion.(*sdm.AuroraPostgres)
		if !ok {
			localV = &sdm.AuroraPostgres{}
		}
		_ = localV
		d.Set("aurora_postgres", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.AWS:
		localV, ok := localVersion.(*sdm.AWS)
		if !ok {
			localV = &sdm.AWS{}
		}
		_ = localV
		d.Set("aws", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"healthcheck_region":                  (v.HealthcheckRegion),
				"name":                                (v.Name),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Azure:
		localV, ok := localVersion.(*sdm.Azure)
		if !ok {
			localV = &sdm.Azure{}
		}
		_ = localV
		d.Set("azure", []map[string]interface{}{
			{
				"app_id":                      seValues["app_id"],
				"secret_store_app_id_path":    seValues["secret_store_app_id_path"],
				"secret_store_app_id_key":     seValues["secret_store_app_id_key"],
				"egress_filter":               (v.EgressFilter),
				"name":                        (v.Name),
				"password":                    seValues["password"],
				"secret_store_password_path":  seValues["secret_store_password_path"],
				"secret_store_password_key":   seValues["secret_store_password_key"],
				"secret_store_id":             (v.SecretStoreID),
				"tags":                        convertTagsToMap(v.Tags),
				"tenant_id":                   seValues["tenant_id"],
				"secret_store_tenant_id_path": seValues["secret_store_tenant_id_path"],
				"secret_store_tenant_id_key":  seValues["secret_store_tenant_id_key"],
			},
		})
	case *sdm.AzureCertificate:
		localV, ok := localVersion.(*sdm.AzureCertificate)
		if !ok {
			localV = &sdm.AzureCertificate{}
		}
		_ = localV
		d.Set("azure_certificate", []map[string]interface{}{
			{
				"app_id":                               seValues["app_id"],
				"secret_store_app_id_path":             seValues["secret_store_app_id_path"],
				"secret_store_app_id_key":              seValues["secret_store_app_id_key"],
				"client_certificate":                   seValues["client_certificate"],
				"secret_store_client_certificate_path": seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":  seValues["secret_store_client_certificate_key"],
				"egress_filter":                        (v.EgressFilter),
				"name":                                 (v.Name),
				"secret_store_id":                      (v.SecretStoreID),
				"tags":                                 convertTagsToMap(v.Tags),
				"tenant_id":                            seValues["tenant_id"],
				"secret_store_tenant_id_path":          seValues["secret_store_tenant_id_path"],
				"secret_store_tenant_id_key":           seValues["secret_store_tenant_id_key"],
			},
		})
	case *sdm.AzurePostgres:
		localV, ok := localVersion.(*sdm.AzurePostgres)
		if !ok {
			localV = &sdm.AzurePostgres{}
		}
		_ = localV
		d.Set("azure_postgres", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.BigQuery:
		localV, ok := localVersion.(*sdm.BigQuery)
		if !ok {
			localV = &sdm.BigQuery{}
		}
		_ = localV
		d.Set("big_query", []map[string]interface{}{
			{
				"egress_filter":                 (v.EgressFilter),
				"endpoint":                      (v.Endpoint),
				"name":                          (v.Name),
				"port_override":                 (v.PortOverride),
				"private_key":                   seValues["private_key"],
				"secret_store_private_key_path": seValues["secret_store_private_key_path"],
				"secret_store_private_key_key":  seValues["secret_store_private_key_key"],
				"project":                       (v.Project),
				"secret_store_id":               (v.SecretStoreID),
				"tags":                          convertTagsToMap(v.Tags),
				"username":                      (v.Username),
			},
		})
	case *sdm.Cassandra:
		localV, ok := localVersion.(*sdm.Cassandra)
		if !ok {
			localV = &sdm.Cassandra{}
		}
		_ = localV
		d.Set("cassandra", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Citus:
		localV, ok := localVersion.(*sdm.Citus)
		if !ok {
			localV = &sdm.Citus{}
		}
		_ = localV
		d.Set("citus", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Clustrix:
		localV, ok := localVersion.(*sdm.Clustrix)
		if !ok {
			localV = &sdm.Clustrix{}
		}
		_ = localV
		d.Set("clustrix", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Cockroach:
		localV, ok := localVersion.(*sdm.Cockroach)
		if !ok {
			localV = &sdm.Cockroach{}
		}
		_ = localV
		d.Set("cockroach", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DB2I:
		localV, ok := localVersion.(*sdm.DB2I)
		if !ok {
			localV = &sdm.DB2I{}
		}
		_ = localV
		d.Set("db_2_i", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DB2LUW:
		localV, ok := localVersion.(*sdm.DB2LUW)
		if !ok {
			localV = &sdm.DB2LUW{}
		}
		_ = localV
		d.Set("db_2_luw", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DocumentDBHost:
		localV, ok := localVersion.(*sdm.DocumentDBHost)
		if !ok {
			localV = &sdm.DocumentDBHost{}
		}
		_ = localV
		d.Set("document_db_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DocumentDBReplicaSet:
		localV, ok := localVersion.(*sdm.DocumentDBReplicaSet)
		if !ok {
			localV = &sdm.DocumentDBReplicaSet{}
		}
		_ = localV
		d.Set("document_db_replica_set", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Druid:
		localV, ok := localVersion.(*sdm.Druid)
		if !ok {
			localV = &sdm.Druid{}
		}
		_ = localV
		d.Set("druid", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.DynamoDB:
		localV, ok := localVersion.(*sdm.DynamoDB)
		if !ok {
			localV = &sdm.DynamoDB{}
		}
		_ = localV
		d.Set("dynamo_db", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Elastic:
		localV, ok := localVersion.(*sdm.Elastic)
		if !ok {
			localV = &sdm.Elastic{}
		}
		_ = localV
		d.Set("elastic", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.ElasticacheRedis:
		localV, ok := localVersion.(*sdm.ElasticacheRedis)
		if !ok {
			localV = &sdm.ElasticacheRedis{}
		}
		_ = localV
		d.Set("elasticache_redis", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
			},
		})
	case *sdm.GCP:
		localV, ok := localVersion.(*sdm.GCP)
		if !ok {
			localV = &sdm.GCP{}
		}
		_ = localV
		d.Set("gcp", []map[string]interface{}{
			{
				"egress_filter":             (v.EgressFilter),
				"keyfile":                   seValues["keyfile"],
				"secret_store_keyfile_path": seValues["secret_store_keyfile_path"],
				"secret_store_keyfile_key":  seValues["secret_store_keyfile_key"],
				"name":                      (v.Name),
				"scopes":                    (v.Scopes),
				"secret_store_id":           (v.SecretStoreID),
				"tags":                      convertTagsToMap(v.Tags),
			},
		})
	case *sdm.GoogleGKE:
		localV, ok := localVersion.(*sdm.GoogleGKE)
		if !ok {
			localV = &sdm.GoogleGKE{}
		}
		_ = localV
		d.Set("google_gke", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"secret_store_id":                         (v.SecretStoreID),
				"service_account_key":                     seValues["service_account_key"],
				"secret_store_service_account_key_path":   seValues["secret_store_service_account_key_path"],
				"secret_store_service_account_key_key":    seValues["secret_store_service_account_key_key"],
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.GoogleGKEUserImpersonation:
		localV, ok := localVersion.(*sdm.GoogleGKEUserImpersonation)
		if !ok {
			localV = &sdm.GoogleGKEUserImpersonation{}
		}
		_ = localV
		d.Set("google_gke_user_impersonation", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"egress_filter":                           (v.EgressFilter),
				"endpoint":                                (v.Endpoint),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"name":                                    (v.Name),
				"secret_store_id":                         (v.SecretStoreID),
				"service_account_key":                     seValues["service_account_key"],
				"secret_store_service_account_key_path":   seValues["secret_store_service_account_key_path"],
				"secret_store_service_account_key_key":    seValues["secret_store_service_account_key_key"],
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Greenplum:
		localV, ok := localVersion.(*sdm.Greenplum)
		if !ok {
			localV = &sdm.Greenplum{}
		}
		_ = localV
		d.Set("greenplum", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.HTTPAuth:
		localV, ok := localVersion.(*sdm.HTTPAuth)
		if !ok {
			localV = &sdm.HTTPAuth{}
		}
		_ = localV
		d.Set("http_auth", []map[string]interface{}{
			{
				"auth_header":                   seValues["auth_header"],
				"secret_store_auth_header_path": seValues["secret_store_auth_header_path"],
				"secret_store_auth_header_key":  seValues["secret_store_auth_header_key"],
				"default_path":                  (v.DefaultPath),
				"egress_filter":                 (v.EgressFilter),
				"headers_blacklist":             (v.HeadersBlacklist),
				"healthcheck_path":              (v.HealthcheckPath),
				"name":                          (v.Name),
				"secret_store_id":               (v.SecretStoreID),
				"subdomain":                     (v.Subdomain),
				"tags":                          convertTagsToMap(v.Tags),
				"url":                           (v.Url),
			},
		})
	case *sdm.HTTPBasicAuth:
		localV, ok := localVersion.(*sdm.HTTPBasicAuth)
		if !ok {
			localV = &sdm.HTTPBasicAuth{}
		}
		_ = localV
		d.Set("http_basic_auth", []map[string]interface{}{
			{
				"default_path":               (v.DefaultPath),
				"egress_filter":              (v.EgressFilter),
				"headers_blacklist":          (v.HeadersBlacklist),
				"healthcheck_path":           (v.HealthcheckPath),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"secret_store_id":            (v.SecretStoreID),
				"subdomain":                  (v.Subdomain),
				"tags":                       convertTagsToMap(v.Tags),
				"url":                        (v.Url),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.HTTPNoAuth:
		localV, ok := localVersion.(*sdm.HTTPNoAuth)
		if !ok {
			localV = &sdm.HTTPNoAuth{}
		}
		_ = localV
		d.Set("http_no_auth", []map[string]interface{}{
			{
				"default_path":      (v.DefaultPath),
				"egress_filter":     (v.EgressFilter),
				"headers_blacklist": (v.HeadersBlacklist),
				"healthcheck_path":  (v.HealthcheckPath),
				"name":              (v.Name),
				"secret_store_id":   (v.SecretStoreID),
				"subdomain":         (v.Subdomain),
				"tags":              convertTagsToMap(v.Tags),
				"url":               (v.Url),
			},
		})
	case *sdm.Kubernetes:
		localV, ok := localVersion.(*sdm.Kubernetes)
		if !ok {
			localV = &sdm.Kubernetes{}
		}
		_ = localV
		d.Set("kubernetes", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.KubernetesBasicAuth:
		localV, ok := localVersion.(*sdm.KubernetesBasicAuth)
		if !ok {
			localV = &sdm.KubernetesBasicAuth{}
		}
		_ = localV
		d.Set("kubernetes_basic_auth", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"healthcheck_namespace":      (v.HealthcheckNamespace),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.KubernetesServiceAccount:
		localV, ok := localVersion.(*sdm.KubernetesServiceAccount)
		if !ok {
			localV = &sdm.KubernetesServiceAccount{}
		}
		_ = localV
		d.Set("kubernetes_service_account", []map[string]interface{}{
			{
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"secret_store_id":         (v.SecretStoreID),
				"tags":                    convertTagsToMap(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.KubernetesServiceAccountUserImpersonation:
		localV, ok := localVersion.(*sdm.KubernetesServiceAccountUserImpersonation)
		if !ok {
			localV = &sdm.KubernetesServiceAccountUserImpersonation{}
		}
		_ = localV
		d.Set("kubernetes_service_account_user_impersonation", []map[string]interface{}{
			{
				"egress_filter":           (v.EgressFilter),
				"healthcheck_namespace":   (v.HealthcheckNamespace),
				"hostname":                (v.Hostname),
				"name":                    (v.Name),
				"port":                    (v.Port),
				"secret_store_id":         (v.SecretStoreID),
				"tags":                    convertTagsToMap(v.Tags),
				"token":                   seValues["token"],
				"secret_store_token_path": seValues["secret_store_token_path"],
				"secret_store_token_key":  seValues["secret_store_token_key"],
			},
		})
	case *sdm.KubernetesUserImpersonation:
		localV, ok := localVersion.(*sdm.KubernetesUserImpersonation)
		if !ok {
			localV = &sdm.KubernetesUserImpersonation{}
		}
		_ = localV
		d.Set("kubernetes_user_impersonation", []map[string]interface{}{
			{
				"certificate_authority":                   seValues["certificate_authority"],
				"secret_store_certificate_authority_path": seValues["secret_store_certificate_authority_path"],
				"secret_store_certificate_authority_key":  seValues["secret_store_certificate_authority_key"],
				"client_certificate":                      seValues["client_certificate"],
				"secret_store_client_certificate_path":    seValues["secret_store_client_certificate_path"],
				"secret_store_client_certificate_key":     seValues["secret_store_client_certificate_key"],
				"client_key":                              seValues["client_key"],
				"secret_store_client_key_path":            seValues["secret_store_client_key_path"],
				"secret_store_client_key_key":             seValues["secret_store_client_key_key"],
				"egress_filter":                           (v.EgressFilter),
				"healthcheck_namespace":                   (v.HealthcheckNamespace),
				"hostname":                                (v.Hostname),
				"name":                                    (v.Name),
				"port":                                    (v.Port),
				"secret_store_id":                         (v.SecretStoreID),
				"tags":                                    convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Maria:
		localV, ok := localVersion.(*sdm.Maria)
		if !ok {
			localV = &sdm.Maria{}
		}
		_ = localV
		d.Set("maria", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Memcached:
		localV, ok := localVersion.(*sdm.Memcached)
		if !ok {
			localV = &sdm.Memcached{}
		}
		_ = localV
		d.Set("memcached", []map[string]interface{}{
			{
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"tags":            convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Memsql:
		localV, ok := localVersion.(*sdm.Memsql)
		if !ok {
			localV = &sdm.Memsql{}
		}
		_ = localV
		d.Set("memsql", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoHost:
		localV, ok := localVersion.(*sdm.MongoHost)
		if !ok {
			localV = &sdm.MongoHost{}
		}
		_ = localV
		d.Set("mongo_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoLegacyHost:
		localV, ok := localVersion.(*sdm.MongoLegacyHost)
		if !ok {
			localV = &sdm.MongoLegacyHost{}
		}
		_ = localV
		d.Set("mongo_legacy_host", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoLegacyReplicaset:
		localV, ok := localVersion.(*sdm.MongoLegacyReplicaset)
		if !ok {
			localV = &sdm.MongoLegacyReplicaset{}
		}
		_ = localV
		d.Set("mongo_legacy_replicaset", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoReplicaSet:
		localV, ok := localVersion.(*sdm.MongoReplicaSet)
		if !ok {
			localV = &sdm.MongoReplicaSet{}
		}
		_ = localV
		d.Set("mongo_replica_set", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"connect_to_replica":         (v.ConnectToReplica),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"replica_set":                (v.ReplicaSet),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.MongoShardedCluster:
		localV, ok := localVersion.(*sdm.MongoShardedCluster)
		if !ok {
			localV = &sdm.MongoShardedCluster{}
		}
		_ = localV
		d.Set("mongo_sharded_cluster", []map[string]interface{}{
			{
				"auth_database":              (v.AuthDatabase),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Mysql:
		localV, ok := localVersion.(*sdm.Mysql)
		if !ok {
			localV = &sdm.Mysql{}
		}
		_ = localV
		d.Set("mysql", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Neptune:
		localV, ok := localVersion.(*sdm.Neptune)
		if !ok {
			localV = &sdm.Neptune{}
		}
		_ = localV
		d.Set("neptune", []map[string]interface{}{
			{
				"egress_filter":   (v.EgressFilter),
				"endpoint":        (v.Endpoint),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"tags":            convertTagsToMap(v.Tags),
			},
		})
	case *sdm.NeptuneIAM:
		localV, ok := localVersion.(*sdm.NeptuneIAM)
		if !ok {
			localV = &sdm.NeptuneIAM{}
		}
		_ = localV
		d.Set("neptune_iam", []map[string]interface{}{
			{
				"access_key":                          seValues["access_key"],
				"secret_store_access_key_path":        seValues["secret_store_access_key_path"],
				"secret_store_access_key_key":         seValues["secret_store_access_key_key"],
				"egress_filter":                       (v.EgressFilter),
				"endpoint":                            (v.Endpoint),
				"name":                                (v.Name),
				"port":                                (v.Port),
				"port_override":                       (v.PortOverride),
				"region":                              (v.Region),
				"role_arn":                            seValues["role_arn"],
				"secret_store_role_arn_path":          seValues["secret_store_role_arn_path"],
				"secret_store_role_arn_key":           seValues["secret_store_role_arn_key"],
				"role_external_id":                    seValues["role_external_id"],
				"secret_store_role_external_id_path":  seValues["secret_store_role_external_id_path"],
				"secret_store_role_external_id_key":   seValues["secret_store_role_external_id_key"],
				"secret_access_key":                   seValues["secret_access_key"],
				"secret_store_secret_access_key_path": seValues["secret_store_secret_access_key_path"],
				"secret_store_secret_access_key_key":  seValues["secret_store_secret_access_key_key"],
				"secret_store_id":                     (v.SecretStoreID),
				"tags":                                convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Oracle:
		localV, ok := localVersion.(*sdm.Oracle)
		if !ok {
			localV = &sdm.Oracle{}
		}
		_ = localV
		d.Set("oracle", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Postgres:
		localV, ok := localVersion.(*sdm.Postgres)
		if !ok {
			localV = &sdm.Postgres{}
		}
		_ = localV
		d.Set("postgres", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Presto:
		localV, ok := localVersion.(*sdm.Presto)
		if !ok {
			localV = &sdm.Presto{}
		}
		_ = localV
		d.Set("presto", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   (v.Username),
			},
		})
	case *sdm.RabbitMQAMQP091:
		localV, ok := localVersion.(*sdm.RabbitMQAMQP091)
		if !ok {
			localV = &sdm.RabbitMQAMQP091{}
		}
		_ = localV
		d.Set("rabbitmq_amqp_091", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"tls_required":               (v.TlsRequired),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.RawTCP:
		localV, ok := localVersion.(*sdm.RawTCP)
		if !ok {
			localV = &sdm.RawTCP{}
		}
		_ = localV
		d.Set("raw_tcp", []map[string]interface{}{
			{
				"egress_filter":   (v.EgressFilter),
				"hostname":        (v.Hostname),
				"name":            (v.Name),
				"port":            (v.Port),
				"port_override":   (v.PortOverride),
				"secret_store_id": (v.SecretStoreID),
				"tags":            convertTagsToMap(v.Tags),
			},
		})
	case *sdm.RDP:
		localV, ok := localVersion.(*sdm.RDP)
		if !ok {
			localV = &sdm.RDP{}
		}
		_ = localV
		d.Set("rdp", []map[string]interface{}{
			{
				"downgrade_nla_connections":  (v.DowngradeNlaConnections),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Redis:
		localV, ok := localVersion.(*sdm.Redis)
		if !ok {
			localV = &sdm.Redis{}
		}
		_ = localV
		d.Set("redis", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
			},
		})
	case *sdm.Redshift:
		localV, ok := localVersion.(*sdm.Redshift)
		if !ok {
			localV = &sdm.Redshift{}
		}
		_ = localV
		d.Set("redshift", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SingleStore:
		localV, ok := localVersion.(*sdm.SingleStore)
		if !ok {
			localV = &sdm.SingleStore{}
		}
		_ = localV
		d.Set("single_store", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Snowflake:
		localV, ok := localVersion.(*sdm.Snowflake)
		if !ok {
			localV = &sdm.Snowflake{}
		}
		_ = localV
		d.Set("snowflake", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port_override":              (v.PortOverride),
				"schema":                     (v.Schema),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SQLServer:
		localV, ok := localVersion.(*sdm.SQLServer)
		if !ok {
			localV = &sdm.SQLServer{}
		}
		_ = localV
		d.Set("sql_server", []map[string]interface{}{
			{
				"database":                   (v.Database),
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"override_database":          (v.OverrideDatabase),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"schema":                     (v.Schema),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSH:
		localV, ok := localVersion.(*sdm.SSH)
		if !ok {
			localV = &sdm.SSH{}
		}
		_ = localV
		d.Set("ssh", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"public_key":                     (v.PublicKey),
				"secret_store_id":                (v.SecretStoreID),
				"tags":                           convertTagsToMap(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSHCert:
		localV, ok := localVersion.(*sdm.SSHCert)
		if !ok {
			localV = &sdm.SSHCert{}
		}
		_ = localV
		d.Set("ssh_cert", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"secret_store_id":                (v.SecretStoreID),
				"tags":                           convertTagsToMap(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.SSHCustomerKey:
		localV, ok := localVersion.(*sdm.SSHCustomerKey)
		if !ok {
			localV = &sdm.SSHCustomerKey{}
		}
		_ = localV
		d.Set("ssh_customer_key", []map[string]interface{}{
			{
				"allow_deprecated_key_exchanges": (v.AllowDeprecatedKeyExchanges),
				"egress_filter":                  (v.EgressFilter),
				"hostname":                       (v.Hostname),
				"name":                           (v.Name),
				"port":                           (v.Port),
				"port_forwarding":                (v.PortForwarding),
				"private_key":                    seValues["private_key"],
				"secret_store_private_key_path":  seValues["secret_store_private_key_path"],
				"secret_store_private_key_key":   seValues["secret_store_private_key_key"],
				"secret_store_id":                (v.SecretStoreID),
				"tags":                           convertTagsToMap(v.Tags),
				"username":                       seValues["username"],
				"secret_store_username_path":     seValues["secret_store_username_path"],
				"secret_store_username_key":      seValues["secret_store_username_key"],
			},
		})
	case *sdm.Sybase:
		localV, ok := localVersion.(*sdm.Sybase)
		if !ok {
			localV = &sdm.Sybase{}
		}
		_ = localV
		d.Set("sybase", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.SybaseIQ:
		localV, ok := localVersion.(*sdm.SybaseIQ)
		if !ok {
			localV = &sdm.SybaseIQ{}
		}
		_ = localV
		d.Set("sybase_iq", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	case *sdm.Teradata:
		localV, ok := localVersion.(*sdm.Teradata)
		if !ok {
			localV = &sdm.Teradata{}
		}
		_ = localV
		d.Set("teradata", []map[string]interface{}{
			{
				"egress_filter":              (v.EgressFilter),
				"hostname":                   (v.Hostname),
				"name":                       (v.Name),
				"password":                   seValues["password"],
				"secret_store_password_path": seValues["secret_store_password_path"],
				"secret_store_password_key":  seValues["secret_store_password_key"],
				"port":                       (v.Port),
				"port_override":              (v.PortOverride),
				"secret_store_id":            (v.SecretStoreID),
				"tags":                       convertTagsToMap(v.Tags),
				"username":                   seValues["username"],
				"secret_store_username_path": seValues["secret_store_username_path"],
				"secret_store_username_key":  seValues["secret_store_username_key"],
			},
		})
	}
	return nil
}
func resourceResourceUpdate(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	_, err := secretStoreValuesForResource(d)
	if err != nil {
		return fmt.Errorf("cannot update Resource %s: %w", d.Id(), err)
	}

	resp, err := cc.Resources().Update(ctx, convertResourceFromResourceData(d))
	if err != nil {
		return fmt.Errorf("cannot update Resource %s: %w", d.Id(), err)
	}
	d.SetId(resp.Resource.GetID())
	return resourceResourceRead(ctx, d, cc)
}
func resourceResourceDelete(ctx context.Context, d *schema.ResourceData, cc *sdm.Client) error {
	var errNotFound *sdm.NotFoundError
	_, err := cc.Resources().Delete(ctx, d.Id())
	if err != nil && errors.As(err, &errNotFound) {
		return nil
	}
	return err
}
